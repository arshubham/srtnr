// This file was generated by gir (e58a8db) from gir-files (469db10)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals)]

extern crate libc;
#[macro_use] extern crate bitflags;

#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, intptr_t, uintptr_t, time_t, FILE};

pub type gboolean = c_int;
pub const GFALSE:  c_int = 0;
pub const GTRUE:   c_int = 1;

pub type gconstpointer = *const c_void;
pub type gpointer = *mut c_void;

#[repr(C)]
#[derive(Debug)]
pub struct Volatile<T>(T);


// Aliases
pub type GDateDay = u8;
pub type GDateYear = u16;
pub type GMutexLocker = c_void;
pub type GPid = c_int;
pub type GQuark = u32;
pub type GStrv = *mut *mut c_char;
pub type GTime = i32;
pub type GTimeSpan = i64;
pub type GType = size_t;

// Enums
pub type GBookmarkFileError = c_int;
pub const G_BOOKMARK_FILE_ERROR_INVALID_URI: GBookmarkFileError = 0;
pub const G_BOOKMARK_FILE_ERROR_INVALID_VALUE: GBookmarkFileError = 1;
pub const G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: GBookmarkFileError = 2;
pub const G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: GBookmarkFileError = 3;
pub const G_BOOKMARK_FILE_ERROR_READ: GBookmarkFileError = 4;
pub const G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: GBookmarkFileError = 5;
pub const G_BOOKMARK_FILE_ERROR_WRITE: GBookmarkFileError = 6;
pub const G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: GBookmarkFileError = 7;

pub type GChecksumType = c_int;
pub const G_CHECKSUM_MD5: GChecksumType = 0;
pub const G_CHECKSUM_SHA1: GChecksumType = 1;
pub const G_CHECKSUM_SHA256: GChecksumType = 2;
pub const G_CHECKSUM_SHA512: GChecksumType = 3;
pub const G_CHECKSUM_SHA384: GChecksumType = 4;

pub type GConvertError = c_int;
pub const G_CONVERT_ERROR_NO_CONVERSION: GConvertError = 0;
pub const G_CONVERT_ERROR_ILLEGAL_SEQUENCE: GConvertError = 1;
pub const G_CONVERT_ERROR_FAILED: GConvertError = 2;
pub const G_CONVERT_ERROR_PARTIAL_INPUT: GConvertError = 3;
pub const G_CONVERT_ERROR_BAD_URI: GConvertError = 4;
pub const G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: GConvertError = 5;
pub const G_CONVERT_ERROR_NO_MEMORY: GConvertError = 6;

pub type GDateDMY = c_int;
pub const G_DATE_DAY: GDateDMY = 0;
pub const G_DATE_MONTH: GDateDMY = 1;
pub const G_DATE_YEAR: GDateDMY = 2;

pub type GDateMonth = c_int;
pub const G_DATE_BAD_MONTH: GDateMonth = 0;
pub const G_DATE_JANUARY: GDateMonth = 1;
pub const G_DATE_FEBRUARY: GDateMonth = 2;
pub const G_DATE_MARCH: GDateMonth = 3;
pub const G_DATE_APRIL: GDateMonth = 4;
pub const G_DATE_MAY: GDateMonth = 5;
pub const G_DATE_JUNE: GDateMonth = 6;
pub const G_DATE_JULY: GDateMonth = 7;
pub const G_DATE_AUGUST: GDateMonth = 8;
pub const G_DATE_SEPTEMBER: GDateMonth = 9;
pub const G_DATE_OCTOBER: GDateMonth = 10;
pub const G_DATE_NOVEMBER: GDateMonth = 11;
pub const G_DATE_DECEMBER: GDateMonth = 12;

pub type GDateWeekday = c_int;
pub const G_DATE_BAD_WEEKDAY: GDateWeekday = 0;
pub const G_DATE_MONDAY: GDateWeekday = 1;
pub const G_DATE_TUESDAY: GDateWeekday = 2;
pub const G_DATE_WEDNESDAY: GDateWeekday = 3;
pub const G_DATE_THURSDAY: GDateWeekday = 4;
pub const G_DATE_FRIDAY: GDateWeekday = 5;
pub const G_DATE_SATURDAY: GDateWeekday = 6;
pub const G_DATE_SUNDAY: GDateWeekday = 7;

pub type GErrorType = c_int;
pub const G_ERR_UNKNOWN: GErrorType = 0;
pub const G_ERR_UNEXP_EOF: GErrorType = 1;
pub const G_ERR_UNEXP_EOF_IN_STRING: GErrorType = 2;
pub const G_ERR_UNEXP_EOF_IN_COMMENT: GErrorType = 3;
pub const G_ERR_NON_DIGIT_IN_CONST: GErrorType = 4;
pub const G_ERR_DIGIT_RADIX: GErrorType = 5;
pub const G_ERR_FLOAT_RADIX: GErrorType = 6;
pub const G_ERR_FLOAT_MALFORMED: GErrorType = 7;

pub type GFileError = c_int;
pub const G_FILE_ERROR_EXIST: GFileError = 0;
pub const G_FILE_ERROR_ISDIR: GFileError = 1;
pub const G_FILE_ERROR_ACCES: GFileError = 2;
pub const G_FILE_ERROR_NAMETOOLONG: GFileError = 3;
pub const G_FILE_ERROR_NOENT: GFileError = 4;
pub const G_FILE_ERROR_NOTDIR: GFileError = 5;
pub const G_FILE_ERROR_NXIO: GFileError = 6;
pub const G_FILE_ERROR_NODEV: GFileError = 7;
pub const G_FILE_ERROR_ROFS: GFileError = 8;
pub const G_FILE_ERROR_TXTBSY: GFileError = 9;
pub const G_FILE_ERROR_FAULT: GFileError = 10;
pub const G_FILE_ERROR_LOOP: GFileError = 11;
pub const G_FILE_ERROR_NOSPC: GFileError = 12;
pub const G_FILE_ERROR_NOMEM: GFileError = 13;
pub const G_FILE_ERROR_MFILE: GFileError = 14;
pub const G_FILE_ERROR_NFILE: GFileError = 15;
pub const G_FILE_ERROR_BADF: GFileError = 16;
pub const G_FILE_ERROR_INVAL: GFileError = 17;
pub const G_FILE_ERROR_PIPE: GFileError = 18;
pub const G_FILE_ERROR_AGAIN: GFileError = 19;
pub const G_FILE_ERROR_INTR: GFileError = 20;
pub const G_FILE_ERROR_IO: GFileError = 21;
pub const G_FILE_ERROR_PERM: GFileError = 22;
pub const G_FILE_ERROR_NOSYS: GFileError = 23;
pub const G_FILE_ERROR_FAILED: GFileError = 24;

pub type GIOChannelError = c_int;
pub const G_IO_CHANNEL_ERROR_FBIG: GIOChannelError = 0;
pub const G_IO_CHANNEL_ERROR_INVAL: GIOChannelError = 1;
pub const G_IO_CHANNEL_ERROR_IO: GIOChannelError = 2;
pub const G_IO_CHANNEL_ERROR_ISDIR: GIOChannelError = 3;
pub const G_IO_CHANNEL_ERROR_NOSPC: GIOChannelError = 4;
pub const G_IO_CHANNEL_ERROR_NXIO: GIOChannelError = 5;
pub const G_IO_CHANNEL_ERROR_OVERFLOW: GIOChannelError = 6;
pub const G_IO_CHANNEL_ERROR_PIPE: GIOChannelError = 7;
pub const G_IO_CHANNEL_ERROR_FAILED: GIOChannelError = 8;

pub type GIOError = c_int;
pub const G_IO_ERROR_NONE: GIOError = 0;
pub const G_IO_ERROR_AGAIN: GIOError = 1;
pub const G_IO_ERROR_INVAL: GIOError = 2;
pub const G_IO_ERROR_UNKNOWN: GIOError = 3;

pub type GIOStatus = c_int;
pub const G_IO_STATUS_ERROR: GIOStatus = 0;
pub const G_IO_STATUS_NORMAL: GIOStatus = 1;
pub const G_IO_STATUS_EOF: GIOStatus = 2;
pub const G_IO_STATUS_AGAIN: GIOStatus = 3;

pub type GKeyFileError = c_int;
pub const G_KEY_FILE_ERROR_UNKNOWN_ENCODING: GKeyFileError = 0;
pub const G_KEY_FILE_ERROR_PARSE: GKeyFileError = 1;
pub const G_KEY_FILE_ERROR_NOT_FOUND: GKeyFileError = 2;
pub const G_KEY_FILE_ERROR_KEY_NOT_FOUND: GKeyFileError = 3;
pub const G_KEY_FILE_ERROR_GROUP_NOT_FOUND: GKeyFileError = 4;
pub const G_KEY_FILE_ERROR_INVALID_VALUE: GKeyFileError = 5;

pub type GLogWriterOutput = c_int;
pub const G_LOG_WRITER_HANDLED: GLogWriterOutput = 1;
pub const G_LOG_WRITER_UNHANDLED: GLogWriterOutput = 0;

pub type GMarkupError = c_int;
pub const G_MARKUP_ERROR_BAD_UTF8: GMarkupError = 0;
pub const G_MARKUP_ERROR_EMPTY: GMarkupError = 1;
pub const G_MARKUP_ERROR_PARSE: GMarkupError = 2;
pub const G_MARKUP_ERROR_UNKNOWN_ELEMENT: GMarkupError = 3;
pub const G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: GMarkupError = 4;
pub const G_MARKUP_ERROR_INVALID_CONTENT: GMarkupError = 5;
pub const G_MARKUP_ERROR_MISSING_ATTRIBUTE: GMarkupError = 6;

pub type GNormalizeMode = c_int;
pub const G_NORMALIZE_DEFAULT: GNormalizeMode = 0;
pub const G_NORMALIZE_DEFAULT_COMPOSE: GNormalizeMode = 1;
pub const G_NORMALIZE_ALL: GNormalizeMode = 2;
pub const G_NORMALIZE_ALL_COMPOSE: GNormalizeMode = 3;

pub type GNumberParserError = c_int;
pub const G_NUMBER_PARSER_ERROR_INVALID: GNumberParserError = 0;
pub const G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: GNumberParserError = 1;

pub type GOnceStatus = c_int;
pub const G_ONCE_STATUS_NOTCALLED: GOnceStatus = 0;
pub const G_ONCE_STATUS_PROGRESS: GOnceStatus = 1;
pub const G_ONCE_STATUS_READY: GOnceStatus = 2;

pub type GOptionArg = c_int;
pub const G_OPTION_ARG_NONE: GOptionArg = 0;
pub const G_OPTION_ARG_STRING: GOptionArg = 1;
pub const G_OPTION_ARG_INT: GOptionArg = 2;
pub const G_OPTION_ARG_CALLBACK: GOptionArg = 3;
pub const G_OPTION_ARG_FILENAME: GOptionArg = 4;
pub const G_OPTION_ARG_STRING_ARRAY: GOptionArg = 5;
pub const G_OPTION_ARG_FILENAME_ARRAY: GOptionArg = 6;
pub const G_OPTION_ARG_DOUBLE: GOptionArg = 7;
pub const G_OPTION_ARG_INT64: GOptionArg = 8;

pub type GOptionError = c_int;
pub const G_OPTION_ERROR_UNKNOWN_OPTION: GOptionError = 0;
pub const G_OPTION_ERROR_BAD_VALUE: GOptionError = 1;
pub const G_OPTION_ERROR_FAILED: GOptionError = 2;

pub type GRegexError = c_int;
pub const G_REGEX_ERROR_COMPILE: GRegexError = 0;
pub const G_REGEX_ERROR_OPTIMIZE: GRegexError = 1;
pub const G_REGEX_ERROR_REPLACE: GRegexError = 2;
pub const G_REGEX_ERROR_MATCH: GRegexError = 3;
pub const G_REGEX_ERROR_INTERNAL: GRegexError = 4;
pub const G_REGEX_ERROR_STRAY_BACKSLASH: GRegexError = 101;
pub const G_REGEX_ERROR_MISSING_CONTROL_CHAR: GRegexError = 102;
pub const G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: GRegexError = 103;
pub const G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: GRegexError = 104;
pub const G_REGEX_ERROR_QUANTIFIER_TOO_BIG: GRegexError = 105;
pub const G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: GRegexError = 106;
pub const G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: GRegexError = 107;
pub const G_REGEX_ERROR_RANGE_OUT_OF_ORDER: GRegexError = 108;
pub const G_REGEX_ERROR_NOTHING_TO_REPEAT: GRegexError = 109;
pub const G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: GRegexError = 112;
pub const G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: GRegexError = 113;
pub const G_REGEX_ERROR_UNMATCHED_PARENTHESIS: GRegexError = 114;
pub const G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: GRegexError = 115;
pub const G_REGEX_ERROR_UNTERMINATED_COMMENT: GRegexError = 118;
pub const G_REGEX_ERROR_EXPRESSION_TOO_LARGE: GRegexError = 120;
pub const G_REGEX_ERROR_MEMORY_ERROR: GRegexError = 121;
pub const G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: GRegexError = 125;
pub const G_REGEX_ERROR_MALFORMED_CONDITION: GRegexError = 126;
pub const G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: GRegexError = 127;
pub const G_REGEX_ERROR_ASSERTION_EXPECTED: GRegexError = 128;
pub const G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: GRegexError = 130;
pub const G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: GRegexError = 131;
pub const G_REGEX_ERROR_HEX_CODE_TOO_LARGE: GRegexError = 134;
pub const G_REGEX_ERROR_INVALID_CONDITION: GRegexError = 135;
pub const G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: GRegexError = 136;
pub const G_REGEX_ERROR_INFINITE_LOOP: GRegexError = 140;
pub const G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: GRegexError = 142;
pub const G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: GRegexError = 143;
pub const G_REGEX_ERROR_MALFORMED_PROPERTY: GRegexError = 146;
pub const G_REGEX_ERROR_UNKNOWN_PROPERTY: GRegexError = 147;
pub const G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: GRegexError = 148;
pub const G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: GRegexError = 149;
pub const G_REGEX_ERROR_INVALID_OCTAL_VALUE: GRegexError = 151;
pub const G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: GRegexError = 154;
pub const G_REGEX_ERROR_DEFINE_REPETION: GRegexError = 155;
pub const G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: GRegexError = 156;
pub const G_REGEX_ERROR_MISSING_BACK_REFERENCE: GRegexError = 157;
pub const G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: GRegexError = 158;
pub const G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: GRegexError = 159;
pub const G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: GRegexError = 160;
pub const G_REGEX_ERROR_NUMBER_TOO_BIG: GRegexError = 161;
pub const G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: GRegexError = 162;
pub const G_REGEX_ERROR_MISSING_DIGIT: GRegexError = 163;
pub const G_REGEX_ERROR_INVALID_DATA_CHARACTER: GRegexError = 164;
pub const G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: GRegexError = 165;
pub const G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: GRegexError = 166;
pub const G_REGEX_ERROR_INVALID_CONTROL_CHAR: GRegexError = 168;
pub const G_REGEX_ERROR_MISSING_NAME: GRegexError = 169;
pub const G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: GRegexError = 171;
pub const G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: GRegexError = 172;
pub const G_REGEX_ERROR_NAME_TOO_LONG: GRegexError = 175;
pub const G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: GRegexError = 176;

pub type GSeekType = c_int;
pub const G_SEEK_CUR: GSeekType = 0;
pub const G_SEEK_SET: GSeekType = 1;
pub const G_SEEK_END: GSeekType = 2;

pub type GShellError = c_int;
pub const G_SHELL_ERROR_BAD_QUOTING: GShellError = 0;
pub const G_SHELL_ERROR_EMPTY_STRING: GShellError = 1;
pub const G_SHELL_ERROR_FAILED: GShellError = 2;

pub type GSliceConfig = c_int;
pub const G_SLICE_CONFIG_ALWAYS_MALLOC: GSliceConfig = 1;
pub const G_SLICE_CONFIG_BYPASS_MAGAZINES: GSliceConfig = 2;
pub const G_SLICE_CONFIG_WORKING_SET_MSECS: GSliceConfig = 3;
pub const G_SLICE_CONFIG_COLOR_INCREMENT: GSliceConfig = 4;
pub const G_SLICE_CONFIG_CHUNK_SIZES: GSliceConfig = 5;
pub const G_SLICE_CONFIG_CONTENTION_COUNTER: GSliceConfig = 6;

pub type GSpawnError = c_int;
pub const G_SPAWN_ERROR_FORK: GSpawnError = 0;
pub const G_SPAWN_ERROR_READ: GSpawnError = 1;
pub const G_SPAWN_ERROR_CHDIR: GSpawnError = 2;
pub const G_SPAWN_ERROR_ACCES: GSpawnError = 3;
pub const G_SPAWN_ERROR_PERM: GSpawnError = 4;
pub const G_SPAWN_ERROR_TOO_BIG: GSpawnError = 5;
pub const G_SPAWN_ERROR_NOEXEC: GSpawnError = 6;
pub const G_SPAWN_ERROR_NAMETOOLONG: GSpawnError = 7;
pub const G_SPAWN_ERROR_NOENT: GSpawnError = 8;
pub const G_SPAWN_ERROR_NOMEM: GSpawnError = 9;
pub const G_SPAWN_ERROR_NOTDIR: GSpawnError = 10;
pub const G_SPAWN_ERROR_LOOP: GSpawnError = 11;
pub const G_SPAWN_ERROR_TXTBUSY: GSpawnError = 12;
pub const G_SPAWN_ERROR_IO: GSpawnError = 13;
pub const G_SPAWN_ERROR_NFILE: GSpawnError = 14;
pub const G_SPAWN_ERROR_MFILE: GSpawnError = 15;
pub const G_SPAWN_ERROR_INVAL: GSpawnError = 16;
pub const G_SPAWN_ERROR_ISDIR: GSpawnError = 17;
pub const G_SPAWN_ERROR_LIBBAD: GSpawnError = 18;
pub const G_SPAWN_ERROR_FAILED: GSpawnError = 19;

pub type GTestFileType = c_int;
pub const G_TEST_DIST: GTestFileType = 0;
pub const G_TEST_BUILT: GTestFileType = 1;

pub type GTestLogType = c_int;
pub const G_TEST_LOG_NONE: GTestLogType = 0;
pub const G_TEST_LOG_ERROR: GTestLogType = 1;
pub const G_TEST_LOG_START_BINARY: GTestLogType = 2;
pub const G_TEST_LOG_LIST_CASE: GTestLogType = 3;
pub const G_TEST_LOG_SKIP_CASE: GTestLogType = 4;
pub const G_TEST_LOG_START_CASE: GTestLogType = 5;
pub const G_TEST_LOG_STOP_CASE: GTestLogType = 6;
pub const G_TEST_LOG_MIN_RESULT: GTestLogType = 7;
pub const G_TEST_LOG_MAX_RESULT: GTestLogType = 8;
pub const G_TEST_LOG_MESSAGE: GTestLogType = 9;
pub const G_TEST_LOG_START_SUITE: GTestLogType = 10;
pub const G_TEST_LOG_STOP_SUITE: GTestLogType = 11;

pub type ThreadError = c_int;
pub const G_THREAD_ERROR_AGAIN: ThreadError = 0;
pub type GThreadError = ThreadError;

pub type GTimeType = c_int;
pub const G_TIME_TYPE_STANDARD: GTimeType = 0;
pub const G_TIME_TYPE_DAYLIGHT: GTimeType = 1;
pub const G_TIME_TYPE_UNIVERSAL: GTimeType = 2;

pub type GTokenType = c_int;
pub const G_TOKEN_EOF: GTokenType = 0;
pub const G_TOKEN_LEFT_PAREN: GTokenType = 40;
pub const G_TOKEN_RIGHT_PAREN: GTokenType = 41;
pub const G_TOKEN_LEFT_CURLY: GTokenType = 123;
pub const G_TOKEN_RIGHT_CURLY: GTokenType = 125;
pub const G_TOKEN_LEFT_BRACE: GTokenType = 91;
pub const G_TOKEN_RIGHT_BRACE: GTokenType = 93;
pub const G_TOKEN_EQUAL_SIGN: GTokenType = 61;
pub const G_TOKEN_COMMA: GTokenType = 44;
pub const G_TOKEN_NONE: GTokenType = 256;
pub const G_TOKEN_ERROR: GTokenType = 257;
pub const G_TOKEN_CHAR: GTokenType = 258;
pub const G_TOKEN_BINARY: GTokenType = 259;
pub const G_TOKEN_OCTAL: GTokenType = 260;
pub const G_TOKEN_INT: GTokenType = 261;
pub const G_TOKEN_HEX: GTokenType = 262;
pub const G_TOKEN_FLOAT: GTokenType = 263;
pub const G_TOKEN_STRING: GTokenType = 264;
pub const G_TOKEN_SYMBOL: GTokenType = 265;
pub const G_TOKEN_IDENTIFIER: GTokenType = 266;
pub const G_TOKEN_IDENTIFIER_NULL: GTokenType = 267;
pub const G_TOKEN_COMMENT_SINGLE: GTokenType = 268;
pub const G_TOKEN_COMMENT_MULTI: GTokenType = 269;

pub type GTraverseType = c_int;
pub const G_IN_ORDER: GTraverseType = 0;
pub const G_PRE_ORDER: GTraverseType = 1;
pub const G_POST_ORDER: GTraverseType = 2;
pub const G_LEVEL_ORDER: GTraverseType = 3;

pub type GUnicodeBreakType = c_int;
pub const G_UNICODE_BREAK_MANDATORY: GUnicodeBreakType = 0;
pub const G_UNICODE_BREAK_CARRIAGE_RETURN: GUnicodeBreakType = 1;
pub const G_UNICODE_BREAK_LINE_FEED: GUnicodeBreakType = 2;
pub const G_UNICODE_BREAK_COMBINING_MARK: GUnicodeBreakType = 3;
pub const G_UNICODE_BREAK_SURROGATE: GUnicodeBreakType = 4;
pub const G_UNICODE_BREAK_ZERO_WIDTH_SPACE: GUnicodeBreakType = 5;
pub const G_UNICODE_BREAK_INSEPARABLE: GUnicodeBreakType = 6;
pub const G_UNICODE_BREAK_NON_BREAKING_GLUE: GUnicodeBreakType = 7;
pub const G_UNICODE_BREAK_CONTINGENT: GUnicodeBreakType = 8;
pub const G_UNICODE_BREAK_SPACE: GUnicodeBreakType = 9;
pub const G_UNICODE_BREAK_AFTER: GUnicodeBreakType = 10;
pub const G_UNICODE_BREAK_BEFORE: GUnicodeBreakType = 11;
pub const G_UNICODE_BREAK_BEFORE_AND_AFTER: GUnicodeBreakType = 12;
pub const G_UNICODE_BREAK_HYPHEN: GUnicodeBreakType = 13;
pub const G_UNICODE_BREAK_NON_STARTER: GUnicodeBreakType = 14;
pub const G_UNICODE_BREAK_OPEN_PUNCTUATION: GUnicodeBreakType = 15;
pub const G_UNICODE_BREAK_CLOSE_PUNCTUATION: GUnicodeBreakType = 16;
pub const G_UNICODE_BREAK_QUOTATION: GUnicodeBreakType = 17;
pub const G_UNICODE_BREAK_EXCLAMATION: GUnicodeBreakType = 18;
pub const G_UNICODE_BREAK_IDEOGRAPHIC: GUnicodeBreakType = 19;
pub const G_UNICODE_BREAK_NUMERIC: GUnicodeBreakType = 20;
pub const G_UNICODE_BREAK_INFIX_SEPARATOR: GUnicodeBreakType = 21;
pub const G_UNICODE_BREAK_SYMBOL: GUnicodeBreakType = 22;
pub const G_UNICODE_BREAK_ALPHABETIC: GUnicodeBreakType = 23;
pub const G_UNICODE_BREAK_PREFIX: GUnicodeBreakType = 24;
pub const G_UNICODE_BREAK_POSTFIX: GUnicodeBreakType = 25;
pub const G_UNICODE_BREAK_COMPLEX_CONTEXT: GUnicodeBreakType = 26;
pub const G_UNICODE_BREAK_AMBIGUOUS: GUnicodeBreakType = 27;
pub const G_UNICODE_BREAK_UNKNOWN: GUnicodeBreakType = 28;
pub const G_UNICODE_BREAK_NEXT_LINE: GUnicodeBreakType = 29;
pub const G_UNICODE_BREAK_WORD_JOINER: GUnicodeBreakType = 30;
pub const G_UNICODE_BREAK_HANGUL_L_JAMO: GUnicodeBreakType = 31;
pub const G_UNICODE_BREAK_HANGUL_V_JAMO: GUnicodeBreakType = 32;
pub const G_UNICODE_BREAK_HANGUL_T_JAMO: GUnicodeBreakType = 33;
pub const G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: GUnicodeBreakType = 34;
pub const G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: GUnicodeBreakType = 35;
pub const G_UNICODE_BREAK_CLOSE_PARANTHESIS: GUnicodeBreakType = 36;
pub const G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: GUnicodeBreakType = 37;
pub const G_UNICODE_BREAK_HEBREW_LETTER: GUnicodeBreakType = 38;
pub const G_UNICODE_BREAK_REGIONAL_INDICATOR: GUnicodeBreakType = 39;
pub const G_UNICODE_BREAK_EMOJI_BASE: GUnicodeBreakType = 40;
pub const G_UNICODE_BREAK_EMOJI_MODIFIER: GUnicodeBreakType = 41;
pub const G_UNICODE_BREAK_ZERO_WIDTH_JOINER: GUnicodeBreakType = 42;

pub type GUnicodeScript = c_int;
pub const G_UNICODE_SCRIPT_INVALID_CODE: GUnicodeScript = -1;
pub const G_UNICODE_SCRIPT_COMMON: GUnicodeScript = 0;
pub const G_UNICODE_SCRIPT_INHERITED: GUnicodeScript = 1;
pub const G_UNICODE_SCRIPT_ARABIC: GUnicodeScript = 2;
pub const G_UNICODE_SCRIPT_ARMENIAN: GUnicodeScript = 3;
pub const G_UNICODE_SCRIPT_BENGALI: GUnicodeScript = 4;
pub const G_UNICODE_SCRIPT_BOPOMOFO: GUnicodeScript = 5;
pub const G_UNICODE_SCRIPT_CHEROKEE: GUnicodeScript = 6;
pub const G_UNICODE_SCRIPT_COPTIC: GUnicodeScript = 7;
pub const G_UNICODE_SCRIPT_CYRILLIC: GUnicodeScript = 8;
pub const G_UNICODE_SCRIPT_DESERET: GUnicodeScript = 9;
pub const G_UNICODE_SCRIPT_DEVANAGARI: GUnicodeScript = 10;
pub const G_UNICODE_SCRIPT_ETHIOPIC: GUnicodeScript = 11;
pub const G_UNICODE_SCRIPT_GEORGIAN: GUnicodeScript = 12;
pub const G_UNICODE_SCRIPT_GOTHIC: GUnicodeScript = 13;
pub const G_UNICODE_SCRIPT_GREEK: GUnicodeScript = 14;
pub const G_UNICODE_SCRIPT_GUJARATI: GUnicodeScript = 15;
pub const G_UNICODE_SCRIPT_GURMUKHI: GUnicodeScript = 16;
pub const G_UNICODE_SCRIPT_HAN: GUnicodeScript = 17;
pub const G_UNICODE_SCRIPT_HANGUL: GUnicodeScript = 18;
pub const G_UNICODE_SCRIPT_HEBREW: GUnicodeScript = 19;
pub const G_UNICODE_SCRIPT_HIRAGANA: GUnicodeScript = 20;
pub const G_UNICODE_SCRIPT_KANNADA: GUnicodeScript = 21;
pub const G_UNICODE_SCRIPT_KATAKANA: GUnicodeScript = 22;
pub const G_UNICODE_SCRIPT_KHMER: GUnicodeScript = 23;
pub const G_UNICODE_SCRIPT_LAO: GUnicodeScript = 24;
pub const G_UNICODE_SCRIPT_LATIN: GUnicodeScript = 25;
pub const G_UNICODE_SCRIPT_MALAYALAM: GUnicodeScript = 26;
pub const G_UNICODE_SCRIPT_MONGOLIAN: GUnicodeScript = 27;
pub const G_UNICODE_SCRIPT_MYANMAR: GUnicodeScript = 28;
pub const G_UNICODE_SCRIPT_OGHAM: GUnicodeScript = 29;
pub const G_UNICODE_SCRIPT_OLD_ITALIC: GUnicodeScript = 30;
pub const G_UNICODE_SCRIPT_ORIYA: GUnicodeScript = 31;
pub const G_UNICODE_SCRIPT_RUNIC: GUnicodeScript = 32;
pub const G_UNICODE_SCRIPT_SINHALA: GUnicodeScript = 33;
pub const G_UNICODE_SCRIPT_SYRIAC: GUnicodeScript = 34;
pub const G_UNICODE_SCRIPT_TAMIL: GUnicodeScript = 35;
pub const G_UNICODE_SCRIPT_TELUGU: GUnicodeScript = 36;
pub const G_UNICODE_SCRIPT_THAANA: GUnicodeScript = 37;
pub const G_UNICODE_SCRIPT_THAI: GUnicodeScript = 38;
pub const G_UNICODE_SCRIPT_TIBETAN: GUnicodeScript = 39;
pub const G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL: GUnicodeScript = 40;
pub const G_UNICODE_SCRIPT_YI: GUnicodeScript = 41;
pub const G_UNICODE_SCRIPT_TAGALOG: GUnicodeScript = 42;
pub const G_UNICODE_SCRIPT_HANUNOO: GUnicodeScript = 43;
pub const G_UNICODE_SCRIPT_BUHID: GUnicodeScript = 44;
pub const G_UNICODE_SCRIPT_TAGBANWA: GUnicodeScript = 45;
pub const G_UNICODE_SCRIPT_BRAILLE: GUnicodeScript = 46;
pub const G_UNICODE_SCRIPT_CYPRIOT: GUnicodeScript = 47;
pub const G_UNICODE_SCRIPT_LIMBU: GUnicodeScript = 48;
pub const G_UNICODE_SCRIPT_OSMANYA: GUnicodeScript = 49;
pub const G_UNICODE_SCRIPT_SHAVIAN: GUnicodeScript = 50;
pub const G_UNICODE_SCRIPT_LINEAR_B: GUnicodeScript = 51;
pub const G_UNICODE_SCRIPT_TAI_LE: GUnicodeScript = 52;
pub const G_UNICODE_SCRIPT_UGARITIC: GUnicodeScript = 53;
pub const G_UNICODE_SCRIPT_NEW_TAI_LUE: GUnicodeScript = 54;
pub const G_UNICODE_SCRIPT_BUGINESE: GUnicodeScript = 55;
pub const G_UNICODE_SCRIPT_GLAGOLITIC: GUnicodeScript = 56;
pub const G_UNICODE_SCRIPT_TIFINAGH: GUnicodeScript = 57;
pub const G_UNICODE_SCRIPT_SYLOTI_NAGRI: GUnicodeScript = 58;
pub const G_UNICODE_SCRIPT_OLD_PERSIAN: GUnicodeScript = 59;
pub const G_UNICODE_SCRIPT_KHAROSHTHI: GUnicodeScript = 60;
pub const G_UNICODE_SCRIPT_UNKNOWN: GUnicodeScript = 61;
pub const G_UNICODE_SCRIPT_BALINESE: GUnicodeScript = 62;
pub const G_UNICODE_SCRIPT_CUNEIFORM: GUnicodeScript = 63;
pub const G_UNICODE_SCRIPT_PHOENICIAN: GUnicodeScript = 64;
pub const G_UNICODE_SCRIPT_PHAGS_PA: GUnicodeScript = 65;
pub const G_UNICODE_SCRIPT_NKO: GUnicodeScript = 66;
pub const G_UNICODE_SCRIPT_KAYAH_LI: GUnicodeScript = 67;
pub const G_UNICODE_SCRIPT_LEPCHA: GUnicodeScript = 68;
pub const G_UNICODE_SCRIPT_REJANG: GUnicodeScript = 69;
pub const G_UNICODE_SCRIPT_SUNDANESE: GUnicodeScript = 70;
pub const G_UNICODE_SCRIPT_SAURASHTRA: GUnicodeScript = 71;
pub const G_UNICODE_SCRIPT_CHAM: GUnicodeScript = 72;
pub const G_UNICODE_SCRIPT_OL_CHIKI: GUnicodeScript = 73;
pub const G_UNICODE_SCRIPT_VAI: GUnicodeScript = 74;
pub const G_UNICODE_SCRIPT_CARIAN: GUnicodeScript = 75;
pub const G_UNICODE_SCRIPT_LYCIAN: GUnicodeScript = 76;
pub const G_UNICODE_SCRIPT_LYDIAN: GUnicodeScript = 77;
pub const G_UNICODE_SCRIPT_AVESTAN: GUnicodeScript = 78;
pub const G_UNICODE_SCRIPT_BAMUM: GUnicodeScript = 79;
pub const G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS: GUnicodeScript = 80;
pub const G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC: GUnicodeScript = 81;
pub const G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI: GUnicodeScript = 82;
pub const G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN: GUnicodeScript = 83;
pub const G_UNICODE_SCRIPT_JAVANESE: GUnicodeScript = 84;
pub const G_UNICODE_SCRIPT_KAITHI: GUnicodeScript = 85;
pub const G_UNICODE_SCRIPT_LISU: GUnicodeScript = 86;
pub const G_UNICODE_SCRIPT_MEETEI_MAYEK: GUnicodeScript = 87;
pub const G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN: GUnicodeScript = 88;
pub const G_UNICODE_SCRIPT_OLD_TURKIC: GUnicodeScript = 89;
pub const G_UNICODE_SCRIPT_SAMARITAN: GUnicodeScript = 90;
pub const G_UNICODE_SCRIPT_TAI_THAM: GUnicodeScript = 91;
pub const G_UNICODE_SCRIPT_TAI_VIET: GUnicodeScript = 92;
pub const G_UNICODE_SCRIPT_BATAK: GUnicodeScript = 93;
pub const G_UNICODE_SCRIPT_BRAHMI: GUnicodeScript = 94;
pub const G_UNICODE_SCRIPT_MANDAIC: GUnicodeScript = 95;
pub const G_UNICODE_SCRIPT_CHAKMA: GUnicodeScript = 96;
pub const G_UNICODE_SCRIPT_MEROITIC_CURSIVE: GUnicodeScript = 97;
pub const G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: GUnicodeScript = 98;
pub const G_UNICODE_SCRIPT_MIAO: GUnicodeScript = 99;
pub const G_UNICODE_SCRIPT_SHARADA: GUnicodeScript = 100;
pub const G_UNICODE_SCRIPT_SORA_SOMPENG: GUnicodeScript = 101;
pub const G_UNICODE_SCRIPT_TAKRI: GUnicodeScript = 102;
pub const G_UNICODE_SCRIPT_BASSA_VAH: GUnicodeScript = 103;
pub const G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN: GUnicodeScript = 104;
pub const G_UNICODE_SCRIPT_DUPLOYAN: GUnicodeScript = 105;
pub const G_UNICODE_SCRIPT_ELBASAN: GUnicodeScript = 106;
pub const G_UNICODE_SCRIPT_GRANTHA: GUnicodeScript = 107;
pub const G_UNICODE_SCRIPT_KHOJKI: GUnicodeScript = 108;
pub const G_UNICODE_SCRIPT_KHUDAWADI: GUnicodeScript = 109;
pub const G_UNICODE_SCRIPT_LINEAR_A: GUnicodeScript = 110;
pub const G_UNICODE_SCRIPT_MAHAJANI: GUnicodeScript = 111;
pub const G_UNICODE_SCRIPT_MANICHAEAN: GUnicodeScript = 112;
pub const G_UNICODE_SCRIPT_MENDE_KIKAKUI: GUnicodeScript = 113;
pub const G_UNICODE_SCRIPT_MODI: GUnicodeScript = 114;
pub const G_UNICODE_SCRIPT_MRO: GUnicodeScript = 115;
pub const G_UNICODE_SCRIPT_NABATAEAN: GUnicodeScript = 116;
pub const G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN: GUnicodeScript = 117;
pub const G_UNICODE_SCRIPT_OLD_PERMIC: GUnicodeScript = 118;
pub const G_UNICODE_SCRIPT_PAHAWH_HMONG: GUnicodeScript = 119;
pub const G_UNICODE_SCRIPT_PALMYRENE: GUnicodeScript = 120;
pub const G_UNICODE_SCRIPT_PAU_CIN_HAU: GUnicodeScript = 121;
pub const G_UNICODE_SCRIPT_PSALTER_PAHLAVI: GUnicodeScript = 122;
pub const G_UNICODE_SCRIPT_SIDDHAM: GUnicodeScript = 123;
pub const G_UNICODE_SCRIPT_TIRHUTA: GUnicodeScript = 124;
pub const G_UNICODE_SCRIPT_WARANG_CITI: GUnicodeScript = 125;
pub const G_UNICODE_SCRIPT_AHOM: GUnicodeScript = 126;
pub const G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: GUnicodeScript = 127;
pub const G_UNICODE_SCRIPT_HATRAN: GUnicodeScript = 128;
pub const G_UNICODE_SCRIPT_MULTANI: GUnicodeScript = 129;
pub const G_UNICODE_SCRIPT_OLD_HUNGARIAN: GUnicodeScript = 130;
pub const G_UNICODE_SCRIPT_SIGNWRITING: GUnicodeScript = 131;
pub const G_UNICODE_SCRIPT_ADLAM: GUnicodeScript = 132;
pub const G_UNICODE_SCRIPT_BHAIKSUKI: GUnicodeScript = 133;
pub const G_UNICODE_SCRIPT_MARCHEN: GUnicodeScript = 134;
pub const G_UNICODE_SCRIPT_NEWA: GUnicodeScript = 135;
pub const G_UNICODE_SCRIPT_OSAGE: GUnicodeScript = 136;
pub const G_UNICODE_SCRIPT_TANGUT: GUnicodeScript = 137;
pub const G_UNICODE_SCRIPT_MASARAM_GONDI: GUnicodeScript = 138;
pub const G_UNICODE_SCRIPT_NUSHU: GUnicodeScript = 139;
pub const G_UNICODE_SCRIPT_SOYOMBO: GUnicodeScript = 140;
pub const G_UNICODE_SCRIPT_ZANABAZAR_SQUARE: GUnicodeScript = 141;

pub type GUnicodeType = c_int;
pub const G_UNICODE_CONTROL: GUnicodeType = 0;
pub const G_UNICODE_FORMAT: GUnicodeType = 1;
pub const G_UNICODE_UNASSIGNED: GUnicodeType = 2;
pub const G_UNICODE_PRIVATE_USE: GUnicodeType = 3;
pub const G_UNICODE_SURROGATE: GUnicodeType = 4;
pub const G_UNICODE_LOWERCASE_LETTER: GUnicodeType = 5;
pub const G_UNICODE_MODIFIER_LETTER: GUnicodeType = 6;
pub const G_UNICODE_OTHER_LETTER: GUnicodeType = 7;
pub const G_UNICODE_TITLECASE_LETTER: GUnicodeType = 8;
pub const G_UNICODE_UPPERCASE_LETTER: GUnicodeType = 9;
pub const G_UNICODE_SPACING_MARK: GUnicodeType = 10;
pub const G_UNICODE_ENCLOSING_MARK: GUnicodeType = 11;
pub const G_UNICODE_NON_SPACING_MARK: GUnicodeType = 12;
pub const G_UNICODE_DECIMAL_NUMBER: GUnicodeType = 13;
pub const G_UNICODE_LETTER_NUMBER: GUnicodeType = 14;
pub const G_UNICODE_OTHER_NUMBER: GUnicodeType = 15;
pub const G_UNICODE_CONNECT_PUNCTUATION: GUnicodeType = 16;
pub const G_UNICODE_DASH_PUNCTUATION: GUnicodeType = 17;
pub const G_UNICODE_CLOSE_PUNCTUATION: GUnicodeType = 18;
pub const G_UNICODE_FINAL_PUNCTUATION: GUnicodeType = 19;
pub const G_UNICODE_INITIAL_PUNCTUATION: GUnicodeType = 20;
pub const G_UNICODE_OTHER_PUNCTUATION: GUnicodeType = 21;
pub const G_UNICODE_OPEN_PUNCTUATION: GUnicodeType = 22;
pub const G_UNICODE_CURRENCY_SYMBOL: GUnicodeType = 23;
pub const G_UNICODE_MODIFIER_SYMBOL: GUnicodeType = 24;
pub const G_UNICODE_MATH_SYMBOL: GUnicodeType = 25;
pub const G_UNICODE_OTHER_SYMBOL: GUnicodeType = 26;
pub const G_UNICODE_LINE_SEPARATOR: GUnicodeType = 27;
pub const G_UNICODE_PARAGRAPH_SEPARATOR: GUnicodeType = 28;
pub const G_UNICODE_SPACE_SEPARATOR: GUnicodeType = 29;

pub type GUserDirectory = c_int;
pub const G_USER_DIRECTORY_DESKTOP: GUserDirectory = 0;
pub const G_USER_DIRECTORY_DOCUMENTS: GUserDirectory = 1;
pub const G_USER_DIRECTORY_DOWNLOAD: GUserDirectory = 2;
pub const G_USER_DIRECTORY_MUSIC: GUserDirectory = 3;
pub const G_USER_DIRECTORY_PICTURES: GUserDirectory = 4;
pub const G_USER_DIRECTORY_PUBLIC_SHARE: GUserDirectory = 5;
pub const G_USER_DIRECTORY_TEMPLATES: GUserDirectory = 6;
pub const G_USER_DIRECTORY_VIDEOS: GUserDirectory = 7;
pub const G_USER_N_DIRECTORIES: GUserDirectory = 8;

pub type GVariantClass = c_int;
pub const G_VARIANT_CLASS_BOOLEAN: GVariantClass = 98;
pub const G_VARIANT_CLASS_BYTE: GVariantClass = 121;
pub const G_VARIANT_CLASS_INT16: GVariantClass = 110;
pub const G_VARIANT_CLASS_UINT16: GVariantClass = 113;
pub const G_VARIANT_CLASS_INT32: GVariantClass = 105;
pub const G_VARIANT_CLASS_UINT32: GVariantClass = 117;
pub const G_VARIANT_CLASS_INT64: GVariantClass = 120;
pub const G_VARIANT_CLASS_UINT64: GVariantClass = 116;
pub const G_VARIANT_CLASS_HANDLE: GVariantClass = 104;
pub const G_VARIANT_CLASS_DOUBLE: GVariantClass = 100;
pub const G_VARIANT_CLASS_STRING: GVariantClass = 115;
pub const G_VARIANT_CLASS_OBJECT_PATH: GVariantClass = 111;
pub const G_VARIANT_CLASS_SIGNATURE: GVariantClass = 103;
pub const G_VARIANT_CLASS_VARIANT: GVariantClass = 118;
pub const G_VARIANT_CLASS_MAYBE: GVariantClass = 109;
pub const G_VARIANT_CLASS_ARRAY: GVariantClass = 97;
pub const G_VARIANT_CLASS_TUPLE: GVariantClass = 40;
pub const G_VARIANT_CLASS_DICT_ENTRY: GVariantClass = 123;

pub type GVariantParseError = c_int;
pub const G_VARIANT_PARSE_ERROR_FAILED: GVariantParseError = 0;
pub const G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED: GVariantParseError = 1;
pub const G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE: GVariantParseError = 2;
pub const G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED: GVariantParseError = 3;
pub const G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END: GVariantParseError = 4;
pub const G_VARIANT_PARSE_ERROR_INVALID_CHARACTER: GVariantParseError = 5;
pub const G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING: GVariantParseError = 6;
pub const G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH: GVariantParseError = 7;
pub const G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE: GVariantParseError = 8;
pub const G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING: GVariantParseError = 9;
pub const G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE: GVariantParseError = 10;
pub const G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE: GVariantParseError = 11;
pub const G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG: GVariantParseError = 12;
pub const G_VARIANT_PARSE_ERROR_TYPE_ERROR: GVariantParseError = 13;
pub const G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN: GVariantParseError = 14;
pub const G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD: GVariantParseError = 15;
pub const G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT: GVariantParseError = 16;
pub const G_VARIANT_PARSE_ERROR_VALUE_EXPECTED: GVariantParseError = 17;

// Constants
pub const G_ANALYZER_ANALYZING: c_int = 1;
pub const G_ASCII_DTOSTR_BUF_SIZE: c_int = 39;
pub const G_BIG_ENDIAN: c_int = 4321;
pub const G_CSET_A_2_Z: *const c_char = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\0" as *const u8 as *const c_char;
pub const G_CSET_DIGITS: *const c_char = b"0123456789\0" as *const u8 as *const c_char;
pub const G_CSET_a_2_z: *const c_char = b"abcdefghijklmnopqrstuvwxyz\0" as *const u8 as *const c_char;
pub const G_DATALIST_FLAGS_MASK: c_int = 3;
pub const G_DATE_BAD_DAY: c_int = 0;
pub const G_DATE_BAD_JULIAN: c_int = 0;
pub const G_DATE_BAD_YEAR: c_int = 0;
pub const G_DIR_SEPARATOR: c_int = 92;
pub const G_DIR_SEPARATOR_S: *const c_char = b"\\\0" as *const u8 as *const c_char;
pub const G_E: c_double = 2.718282;
pub const G_GINT16_FORMAT: *const c_char = b"hi\0" as *const u8 as *const c_char;
pub const G_GINT16_MODIFIER: *const c_char = b"h\0" as *const u8 as *const c_char;
pub const G_GINT32_FORMAT: *const c_char = b"i\0" as *const u8 as *const c_char;
pub const G_GINT32_MODIFIER: *const c_char = b"\0" as *const u8 as *const c_char;
//pub const G_GINT64_FORMAT: *const c_char = b"li\0" as *const u8 as *const c_char;
//pub const G_GINT64_MODIFIER: *const c_char = b"l\0" as *const u8 as *const c_char;
//pub const G_GINTPTR_FORMAT: *const c_char = b"li\0" as *const u8 as *const c_char;
//pub const G_GINTPTR_MODIFIER: *const c_char = b"l\0" as *const u8 as *const c_char;
pub const G_GNUC_FUNCTION: *const c_char = b"\0" as *const u8 as *const c_char;
pub const G_GNUC_PRETTY_FUNCTION: *const c_char = b"\0" as *const u8 as *const c_char;
//pub const G_GSIZE_FORMAT: *const c_char = b"lu\0" as *const u8 as *const c_char;
//pub const G_GSIZE_MODIFIER: *const c_char = b"l\0" as *const u8 as *const c_char;
//pub const G_GSSIZE_FORMAT: *const c_char = b"li\0" as *const u8 as *const c_char;
//pub const G_GSSIZE_MODIFIER: *const c_char = b"l\0" as *const u8 as *const c_char;
pub const G_GUINT16_FORMAT: *const c_char = b"hu\0" as *const u8 as *const c_char;
pub const G_GUINT32_FORMAT: *const c_char = b"u\0" as *const u8 as *const c_char;
//pub const G_GUINT64_FORMAT: *const c_char = b"lu\0" as *const u8 as *const c_char;
//pub const G_GUINTPTR_FORMAT: *const c_char = b"lu\0" as *const u8 as *const c_char;
pub const G_HAVE_GINT64: c_int = 1;
pub const G_HAVE_GNUC_VARARGS: c_int = 1;
pub const G_HAVE_GNUC_VISIBILITY: c_int = 1;
pub const G_HAVE_GROWING_STACK: c_int = 0;
pub const G_HAVE_ISO_VARARGS: c_int = 1;
pub const G_HOOK_FLAG_USER_SHIFT: c_int = 4;
pub const G_IEEE754_DOUBLE_BIAS: c_int = 1023;
pub const G_IEEE754_FLOAT_BIAS: c_int = 127;
pub const G_KEY_FILE_DESKTOP_GROUP: *const c_char = b"Desktop Entry\0" as *const u8 as *const c_char;
pub const G_KEY_FILE_DESKTOP_KEY_ACTIONS: *const c_char = b"Actions\0" as *const u8 as *const c_char;
pub const G_KEY_FILE_DESKTOP_KEY_CATEGORIES: *const c_char = b"Categories\0" as *const u8 as *const c_char;
pub const G_KEY_FILE_DESKTOP_KEY_COMMENT: *const c_char = b"Comment\0" as *const u8 as *const c_char;
pub const G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE: *const c_char = b"DBusActivatable\0" as *const u8 as *const c_char;
pub const G_KEY_FILE_DESKTOP_KEY_EXEC: *const c_char = b"Exec\0" as *const u8 as *const c_char;
pub const G_KEY_FILE_DESKTOP_KEY_FULLNAME: *const c_char = b"X-GNOME-FullName\0" as *const u8 as *const c_char;
pub const G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME: *const c_char = b"GenericName\0" as *const u8 as *const c_char;
pub const G_KEY_FILE_DESKTOP_KEY_GETTEXT_DOMAIN: *const c_char = b"X-GNOME-Gettext-Domain\0" as *const u8 as *const c_char;
pub const G_KEY_FILE_DESKTOP_KEY_HIDDEN: *const c_char = b"Hidden\0" as *const u8 as *const c_char;
pub const G_KEY_FILE_DESKTOP_KEY_ICON: *const c_char = b"Icon\0" as *const u8 as *const c_char;
pub const G_KEY_FILE_DESKTOP_KEY_KEYWORDS: *const c_char = b"Keywords\0" as *const u8 as *const c_char;
pub const G_KEY_FILE_DESKTOP_KEY_MIME_TYPE: *const c_char = b"MimeType\0" as *const u8 as *const c_char;
pub const G_KEY_FILE_DESKTOP_KEY_NAME: *const c_char = b"Name\0" as *const u8 as *const c_char;
pub const G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN: *const c_char = b"NotShowIn\0" as *const u8 as *const c_char;
pub const G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY: *const c_char = b"NoDisplay\0" as *const u8 as *const c_char;
pub const G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN: *const c_char = b"OnlyShowIn\0" as *const u8 as *const c_char;
pub const G_KEY_FILE_DESKTOP_KEY_PATH: *const c_char = b"Path\0" as *const u8 as *const c_char;
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY: *const c_char = b"StartupNotify\0" as *const u8 as *const c_char;
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS: *const c_char = b"StartupWMClass\0" as *const u8 as *const c_char;
pub const G_KEY_FILE_DESKTOP_KEY_TERMINAL: *const c_char = b"Terminal\0" as *const u8 as *const c_char;
pub const G_KEY_FILE_DESKTOP_KEY_TRY_EXEC: *const c_char = b"TryExec\0" as *const u8 as *const c_char;
pub const G_KEY_FILE_DESKTOP_KEY_TYPE: *const c_char = b"Type\0" as *const u8 as *const c_char;
pub const G_KEY_FILE_DESKTOP_KEY_URL: *const c_char = b"URL\0" as *const u8 as *const c_char;
pub const G_KEY_FILE_DESKTOP_KEY_VERSION: *const c_char = b"Version\0" as *const u8 as *const c_char;
pub const G_KEY_FILE_DESKTOP_TYPE_APPLICATION: *const c_char = b"Application\0" as *const u8 as *const c_char;
pub const G_KEY_FILE_DESKTOP_TYPE_DIRECTORY: *const c_char = b"Directory\0" as *const u8 as *const c_char;
pub const G_KEY_FILE_DESKTOP_TYPE_LINK: *const c_char = b"Link\0" as *const u8 as *const c_char;
pub const G_LITTLE_ENDIAN: c_int = 1234;
pub const G_LN10: c_double = 2.302585;
pub const G_LN2: c_double = 0.693147;
pub const G_LOG_2_BASE_10: c_double = 0.301030;
pub const G_LOG_DOMAIN: c_char = 0;
pub const G_LOG_FATAL_MASK: c_int = 0;
pub const G_LOG_LEVEL_USER_SHIFT: c_int = 8;
pub const GLIB_MAJOR_VERSION: c_int = 2;
pub const G_MAXINT16: i16 = 32767;
pub const G_MAXINT32: i32 = 2147483647;
pub const G_MAXINT64: i64 = 9223372036854775807;
pub const G_MAXINT8: i8 = 127;
pub const G_MAXUINT16: u16 = 65535;
pub const G_MAXUINT32: u32 = 4294967295;
pub const G_MAXUINT64: u64 = 18446744073709551615;
pub const G_MAXUINT8: u8 = 255;
pub const GLIB_MICRO_VERSION: c_int = 4;
//pub const G_MININT16: i16 = -32768;
//pub const G_MININT32: i32 = -2147483648;
pub const G_MININT64: i64 = -9223372036854775808;
//pub const G_MININT8: i8 = -128;
pub const GLIB_MINOR_VERSION: c_int = 53;
pub const G_MODULE_SUFFIX: *const c_char = b"so\0" as *const u8 as *const c_char;
pub const G_OPTION_REMAINING: *const c_char = b"\0" as *const u8 as *const c_char;
pub const G_PDP_ENDIAN: c_int = 3412;
pub const G_PI: c_double = 3.141593;
pub const G_PID_FORMAT: *const c_char = b"i\0" as *const u8 as *const c_char;
pub const G_PI_2: c_double = 1.570796;
pub const G_PI_4: c_double = 0.785398;
pub const G_POLLFD_FORMAT: *const c_char = b"%d\0" as *const u8 as *const c_char;
pub const G_PRIORITY_DEFAULT: c_int = 0;
pub const G_PRIORITY_DEFAULT_IDLE: c_int = 200;
pub const G_PRIORITY_HIGH: c_int = -100;
pub const G_PRIORITY_HIGH_IDLE: c_int = 100;
pub const G_PRIORITY_LOW: c_int = 300;
pub const G_SEARCHPATH_SEPARATOR: c_int = 59;
pub const G_SEARCHPATH_SEPARATOR_S: *const c_char = b";\0" as *const u8 as *const c_char;
//pub const GLIB_SIZEOF_LONG: c_int = 8;
//pub const GLIB_SIZEOF_SIZE_T: c_int = 8;
//pub const GLIB_SIZEOF_SSIZE_T: c_int = 8;
//pub const GLIB_SIZEOF_VOID_P: c_int = 8;
pub const G_SOURCE_CONTINUE: gboolean = GTRUE;
pub const G_SOURCE_REMOVE: gboolean = GFALSE;
pub const G_SQRT2: c_double = 1.414214;
pub const G_STR_DELIMITERS: *const c_char = b"_-|> <.\0" as *const u8 as *const c_char;
pub const GLIB_SYSDEF_AF_INET: c_int = 2;
pub const GLIB_SYSDEF_AF_INET6: c_int = 10;
pub const GLIB_SYSDEF_AF_UNIX: c_int = 1;
pub const GLIB_SYSDEF_MSG_DONTROUTE: c_int = 4;
pub const GLIB_SYSDEF_MSG_OOB: c_int = 1;
pub const GLIB_SYSDEF_MSG_PEEK: c_int = 2;
pub const G_TIME_SPAN_DAY: i64 = 86400000000;
pub const G_TIME_SPAN_HOUR: i64 = 3600000000;
pub const G_TIME_SPAN_MILLISECOND: i64 = 1000;
pub const G_TIME_SPAN_MINUTE: i64 = 60000000;
pub const G_TIME_SPAN_SECOND: i64 = 1000000;
pub const G_UNICHAR_MAX_DECOMPOSITION_LENGTH: c_int = 18;
pub const G_URI_RESERVED_CHARS_GENERIC_DELIMITERS: *const c_char = b":/?#[]@\0" as *const u8 as *const c_char;
pub const G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS: *const c_char = b"!$&\'()*+,;=\0" as *const u8 as *const c_char;
pub const G_USEC_PER_SEC: c_int = 1000000;
//pub const G_VA_COPY_AS_ARRAY: c_int = 1;
pub const GLIB_VERSION_MIN_REQUIRED: c_int = 2;
pub const G_WIN32_MSG_HANDLE: c_int = 19981206;

// Flags
bitflags! {
    #[repr(C)]
    pub struct GAsciiType: c_uint {
        const ALNUM = 1;
        const ALPHA = 2;
        const CNTRL = 4;
        const DIGIT = 8;
        const GRAPH = 16;
        const LOWER = 32;
        const PRINT = 64;
        const PUNCT = 128;
        const SPACE = 256;
        const UPPER = 512;
        const XDIGIT = 1024;
    }
}
pub const G_ASCII_ALNUM: GAsciiType = GAsciiType::ALNUM;
pub const G_ASCII_ALPHA: GAsciiType = GAsciiType::ALPHA;
pub const G_ASCII_CNTRL: GAsciiType = GAsciiType::CNTRL;
pub const G_ASCII_DIGIT: GAsciiType = GAsciiType::DIGIT;
pub const G_ASCII_GRAPH: GAsciiType = GAsciiType::GRAPH;
pub const G_ASCII_LOWER: GAsciiType = GAsciiType::LOWER;
pub const G_ASCII_PRINT: GAsciiType = GAsciiType::PRINT;
pub const G_ASCII_PUNCT: GAsciiType = GAsciiType::PUNCT;
pub const G_ASCII_SPACE: GAsciiType = GAsciiType::SPACE;
pub const G_ASCII_UPPER: GAsciiType = GAsciiType::UPPER;
pub const G_ASCII_XDIGIT: GAsciiType = GAsciiType::XDIGIT;

bitflags! {
    #[repr(C)]
    pub struct GFileTest: c_uint {
        const IS_REGULAR = 1;
        const IS_SYMLINK = 2;
        const IS_DIR = 4;
        const IS_EXECUTABLE = 8;
        const EXISTS = 16;
    }
}
pub const G_FILE_TEST_IS_REGULAR: GFileTest = GFileTest::IS_REGULAR;
pub const G_FILE_TEST_IS_SYMLINK: GFileTest = GFileTest::IS_SYMLINK;
pub const G_FILE_TEST_IS_DIR: GFileTest = GFileTest::IS_DIR;
pub const G_FILE_TEST_IS_EXECUTABLE: GFileTest = GFileTest::IS_EXECUTABLE;
pub const G_FILE_TEST_EXISTS: GFileTest = GFileTest::EXISTS;

bitflags! {
    #[repr(C)]
    pub struct GFormatSizeFlags: c_uint {
        const DEFAULT = 0;
        const LONG_FORMAT = 1;
        const IEC_UNITS = 2;
    }
}
pub const G_FORMAT_SIZE_DEFAULT: GFormatSizeFlags = GFormatSizeFlags::DEFAULT;
pub const G_FORMAT_SIZE_LONG_FORMAT: GFormatSizeFlags = GFormatSizeFlags::LONG_FORMAT;
pub const G_FORMAT_SIZE_IEC_UNITS: GFormatSizeFlags = GFormatSizeFlags::IEC_UNITS;

bitflags! {
    #[repr(C)]
    pub struct GHookFlagMask: c_uint {
        const ACTIVE = 1;
        const IN_CALL = 2;
        const MASK = 15;
    }
}
pub const G_HOOK_FLAG_ACTIVE: GHookFlagMask = GHookFlagMask::ACTIVE;
pub const G_HOOK_FLAG_IN_CALL: GHookFlagMask = GHookFlagMask::IN_CALL;
pub const G_HOOK_FLAG_MASK: GHookFlagMask = GHookFlagMask::MASK;

bitflags! {
    #[repr(C)]
    pub struct GIOCondition: c_uint {
        const IN = 1;
        const OUT = 4;
        const PRI = 2;
        const ERR = 8;
        const HUP = 16;
        const NVAL = 32;
    }
}
pub const G_IO_IN: GIOCondition = GIOCondition::IN;
pub const G_IO_OUT: GIOCondition = GIOCondition::OUT;
pub const G_IO_PRI: GIOCondition = GIOCondition::PRI;
pub const G_IO_ERR: GIOCondition = GIOCondition::ERR;
pub const G_IO_HUP: GIOCondition = GIOCondition::HUP;
pub const G_IO_NVAL: GIOCondition = GIOCondition::NVAL;

bitflags! {
    #[repr(C)]
    pub struct GIOFlags: c_uint {
        const APPEND = 1;
        const NONBLOCK = 2;
        const IS_READABLE = 4;
        const IS_WRITABLE = 8;
        const IS_WRITEABLE = 8;
        const IS_SEEKABLE = 16;
        const MASK = 31;
        const GET_MASK = 31;
        const SET_MASK = 3;
    }
}
pub const G_IO_FLAG_APPEND: GIOFlags = GIOFlags::APPEND;
pub const G_IO_FLAG_NONBLOCK: GIOFlags = GIOFlags::NONBLOCK;
pub const G_IO_FLAG_IS_READABLE: GIOFlags = GIOFlags::IS_READABLE;
pub const G_IO_FLAG_IS_WRITABLE: GIOFlags = GIOFlags::IS_WRITEABLE;
pub const G_IO_FLAG_IS_WRITEABLE: GIOFlags = GIOFlags::IS_WRITEABLE;
pub const G_IO_FLAG_IS_SEEKABLE: GIOFlags = GIOFlags::IS_SEEKABLE;
pub const G_IO_FLAG_MASK: GIOFlags = GIOFlags::GET_MASK;
pub const G_IO_FLAG_GET_MASK: GIOFlags = GIOFlags::GET_MASK;
pub const G_IO_FLAG_SET_MASK: GIOFlags = GIOFlags::SET_MASK;

bitflags! {
    #[repr(C)]
    pub struct GKeyFileFlags: c_uint {
        const NONE = 0;
        const KEEP_COMMENTS = 1;
        const KEEP_TRANSLATIONS = 2;
    }
}
pub const G_KEY_FILE_NONE: GKeyFileFlags = GKeyFileFlags::NONE;
pub const G_KEY_FILE_KEEP_COMMENTS: GKeyFileFlags = GKeyFileFlags::KEEP_COMMENTS;
pub const G_KEY_FILE_KEEP_TRANSLATIONS: GKeyFileFlags = GKeyFileFlags::KEEP_TRANSLATIONS;

bitflags! {
    #[repr(C)]
    pub struct GLogLevelFlags: c_uint {
        const FLAG_RECURSION = 1;
        const FLAG_FATAL = 2;
        const LEVEL_ERROR = 4;
        const LEVEL_CRITICAL = 8;
        const LEVEL_WARNING = 16;
        const LEVEL_MESSAGE = 32;
        const LEVEL_INFO = 64;
        const LEVEL_DEBUG = 128;
        const LEVEL_MASK = 4294967292;
    }
}
pub const G_LOG_FLAG_RECURSION: GLogLevelFlags = GLogLevelFlags::FLAG_RECURSION;
pub const G_LOG_FLAG_FATAL: GLogLevelFlags = GLogLevelFlags::FLAG_FATAL;
pub const G_LOG_LEVEL_ERROR: GLogLevelFlags = GLogLevelFlags::LEVEL_ERROR;
pub const G_LOG_LEVEL_CRITICAL: GLogLevelFlags = GLogLevelFlags::LEVEL_CRITICAL;
pub const G_LOG_LEVEL_WARNING: GLogLevelFlags = GLogLevelFlags::LEVEL_WARNING;
pub const G_LOG_LEVEL_MESSAGE: GLogLevelFlags = GLogLevelFlags::LEVEL_MESSAGE;
pub const G_LOG_LEVEL_INFO: GLogLevelFlags = GLogLevelFlags::LEVEL_INFO;
pub const G_LOG_LEVEL_DEBUG: GLogLevelFlags = GLogLevelFlags::LEVEL_DEBUG;
pub const G_LOG_LEVEL_MASK: GLogLevelFlags = GLogLevelFlags::LEVEL_MASK;

bitflags! {
    #[repr(C)]
    pub struct GMarkupCollectType: c_uint {
        const INVALID = 0;
        const STRING = 1;
        const STRDUP = 2;
        const BOOLEAN = 3;
        const TRISTATE = 4;
        const OPTIONAL = 65536;
    }
}
pub const G_MARKUP_COLLECT_INVALID: GMarkupCollectType = GMarkupCollectType::INVALID;
pub const G_MARKUP_COLLECT_STRING: GMarkupCollectType = GMarkupCollectType::STRING;
pub const G_MARKUP_COLLECT_STRDUP: GMarkupCollectType = GMarkupCollectType::STRDUP;
pub const G_MARKUP_COLLECT_BOOLEAN: GMarkupCollectType = GMarkupCollectType::BOOLEAN;
pub const G_MARKUP_COLLECT_TRISTATE: GMarkupCollectType = GMarkupCollectType::TRISTATE;
pub const G_MARKUP_COLLECT_OPTIONAL: GMarkupCollectType = GMarkupCollectType::OPTIONAL;

bitflags! {
    #[repr(C)]
    pub struct GMarkupParseFlags: c_uint {
        const DO_NOT_USE_THIS_UNSUPPORTED_FLAG = 1;
        const TREAT_CDATA_AS_TEXT = 2;
        const PREFIX_ERROR_POSITION = 4;
        const IGNORE_QUALIFIED = 8;
    }
}
pub const G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: GMarkupParseFlags = GMarkupParseFlags::DO_NOT_USE_THIS_UNSUPPORTED_FLAG;
pub const G_MARKUP_TREAT_CDATA_AS_TEXT: GMarkupParseFlags = GMarkupParseFlags::TREAT_CDATA_AS_TEXT;
pub const G_MARKUP_PREFIX_ERROR_POSITION: GMarkupParseFlags = GMarkupParseFlags::PREFIX_ERROR_POSITION;
pub const G_MARKUP_IGNORE_QUALIFIED: GMarkupParseFlags = GMarkupParseFlags::IGNORE_QUALIFIED;

bitflags! {
    #[repr(C)]
    pub struct GOptionFlags: c_uint {
        const NONE = 0;
        const HIDDEN = 1;
        const IN_MAIN = 2;
        const REVERSE = 4;
        const NO_ARG = 8;
        const FILENAME = 16;
        const OPTIONAL_ARG = 32;
        const NOALIAS = 64;
    }
}
pub const G_OPTION_FLAG_NONE: GOptionFlags = GOptionFlags::NONE;
pub const G_OPTION_FLAG_HIDDEN: GOptionFlags = GOptionFlags::HIDDEN;
pub const G_OPTION_FLAG_IN_MAIN: GOptionFlags = GOptionFlags::IN_MAIN;
pub const G_OPTION_FLAG_REVERSE: GOptionFlags = GOptionFlags::REVERSE;
pub const G_OPTION_FLAG_NO_ARG: GOptionFlags = GOptionFlags::NO_ARG;
pub const G_OPTION_FLAG_FILENAME: GOptionFlags = GOptionFlags::FILENAME;
pub const G_OPTION_FLAG_OPTIONAL_ARG: GOptionFlags = GOptionFlags::OPTIONAL_ARG;
pub const G_OPTION_FLAG_NOALIAS: GOptionFlags = GOptionFlags::NOALIAS;

bitflags! {
    #[repr(C)]
    pub struct GRegexCompileFlags: c_uint {
        const CASELESS = 1;
        const MULTILINE = 2;
        const DOTALL = 4;
        const EXTENDED = 8;
        const ANCHORED = 16;
        const DOLLAR_ENDONLY = 32;
        const UNGREEDY = 512;
        const RAW = 2048;
        const NO_AUTO_CAPTURE = 4096;
        const OPTIMIZE = 8192;
        const FIRSTLINE = 262144;
        const DUPNAMES = 524288;
        const NEWLINE_CR = 1048576;
        const NEWLINE_LF = 2097152;
        const NEWLINE_CRLF = 3145728;
        const NEWLINE_ANYCRLF = 5242880;
        const BSR_ANYCRLF = 8388608;
        const JAVASCRIPT_COMPAT = 33554432;
    }
}
pub const G_REGEX_CASELESS: GRegexCompileFlags = GRegexCompileFlags::CASELESS;
pub const G_REGEX_MULTILINE: GRegexCompileFlags = GRegexCompileFlags::MULTILINE;
pub const G_REGEX_DOTALL: GRegexCompileFlags = GRegexCompileFlags::DOTALL;
pub const G_REGEX_EXTENDED: GRegexCompileFlags = GRegexCompileFlags::EXTENDED;
pub const G_REGEX_ANCHORED: GRegexCompileFlags = GRegexCompileFlags::ANCHORED;
pub const G_REGEX_DOLLAR_ENDONLY: GRegexCompileFlags = GRegexCompileFlags::DOLLAR_ENDONLY;
pub const G_REGEX_UNGREEDY: GRegexCompileFlags = GRegexCompileFlags::UNGREEDY;
pub const G_REGEX_RAW: GRegexCompileFlags = GRegexCompileFlags::RAW;
pub const G_REGEX_NO_AUTO_CAPTURE: GRegexCompileFlags = GRegexCompileFlags::NO_AUTO_CAPTURE;
pub const G_REGEX_OPTIMIZE: GRegexCompileFlags = GRegexCompileFlags::OPTIMIZE;
pub const G_REGEX_FIRSTLINE: GRegexCompileFlags = GRegexCompileFlags::FIRSTLINE;
pub const G_REGEX_DUPNAMES: GRegexCompileFlags = GRegexCompileFlags::DUPNAMES;
pub const G_REGEX_NEWLINE_CR: GRegexCompileFlags = GRegexCompileFlags::NEWLINE_CR;
pub const G_REGEX_NEWLINE_LF: GRegexCompileFlags = GRegexCompileFlags::NEWLINE_LF;
pub const G_REGEX_NEWLINE_CRLF: GRegexCompileFlags = GRegexCompileFlags::NEWLINE_CRLF;
pub const G_REGEX_NEWLINE_ANYCRLF: GRegexCompileFlags = GRegexCompileFlags::NEWLINE_ANYCRLF;
pub const G_REGEX_BSR_ANYCRLF: GRegexCompileFlags = GRegexCompileFlags::BSR_ANYCRLF;
pub const G_REGEX_JAVASCRIPT_COMPAT: GRegexCompileFlags = GRegexCompileFlags::JAVASCRIPT_COMPAT;

bitflags! {
    #[repr(C)]
    pub struct GRegexMatchFlags: c_uint {
        const ANCHORED = 16;
        const NOTBOL = 128;
        const NOTEOL = 256;
        const NOTEMPTY = 1024;
        const PARTIAL = 32768;
        const NEWLINE_CR = 1048576;
        const NEWLINE_LF = 2097152;
        const NEWLINE_CRLF = 3145728;
        const NEWLINE_ANY = 4194304;
        const NEWLINE_ANYCRLF = 5242880;
        const BSR_ANYCRLF = 8388608;
        const BSR_ANY = 16777216;
        const PARTIAL_SOFT = 32768;
        const PARTIAL_HARD = 134217728;
        const NOTEMPTY_ATSTART = 268435456;
    }
}
pub const G_REGEX_MATCH_ANCHORED: GRegexMatchFlags = GRegexMatchFlags::ANCHORED;
pub const G_REGEX_MATCH_NOTBOL: GRegexMatchFlags = GRegexMatchFlags::NOTBOL;
pub const G_REGEX_MATCH_NOTEOL: GRegexMatchFlags = GRegexMatchFlags::NOTEOL;
pub const G_REGEX_MATCH_NOTEMPTY: GRegexMatchFlags = GRegexMatchFlags::NOTEMPTY;
pub const G_REGEX_MATCH_PARTIAL: GRegexMatchFlags = GRegexMatchFlags::PARTIAL_SOFT;
pub const G_REGEX_MATCH_NEWLINE_CR: GRegexMatchFlags = GRegexMatchFlags::NEWLINE_CR;
pub const G_REGEX_MATCH_NEWLINE_LF: GRegexMatchFlags = GRegexMatchFlags::NEWLINE_LF;
pub const G_REGEX_MATCH_NEWLINE_CRLF: GRegexMatchFlags = GRegexMatchFlags::NEWLINE_CRLF;
pub const G_REGEX_MATCH_NEWLINE_ANY: GRegexMatchFlags = GRegexMatchFlags::NEWLINE_ANY;
pub const G_REGEX_MATCH_NEWLINE_ANYCRLF: GRegexMatchFlags = GRegexMatchFlags::NEWLINE_ANYCRLF;
pub const G_REGEX_MATCH_BSR_ANYCRLF: GRegexMatchFlags = GRegexMatchFlags::BSR_ANYCRLF;
pub const G_REGEX_MATCH_BSR_ANY: GRegexMatchFlags = GRegexMatchFlags::BSR_ANY;
pub const G_REGEX_MATCH_PARTIAL_SOFT: GRegexMatchFlags = GRegexMatchFlags::PARTIAL_SOFT;
pub const G_REGEX_MATCH_PARTIAL_HARD: GRegexMatchFlags = GRegexMatchFlags::PARTIAL_HARD;
pub const G_REGEX_MATCH_NOTEMPTY_ATSTART: GRegexMatchFlags = GRegexMatchFlags::NOTEMPTY_ATSTART;

bitflags! {
    #[repr(C)]
    pub struct GSpawnFlags: c_uint {
        const DEFAULT = 0;
        const LEAVE_DESCRIPTORS_OPEN = 1;
        const DO_NOT_REAP_CHILD = 2;
        const SEARCH_PATH = 4;
        const STDOUT_TO_DEV_NULL = 8;
        const STDERR_TO_DEV_NULL = 16;
        const CHILD_INHERITS_STDIN = 32;
        const FILE_AND_ARGV_ZERO = 64;
        const SEARCH_PATH_FROM_ENVP = 128;
        const CLOEXEC_PIPES = 256;
    }
}
pub const G_SPAWN_DEFAULT: GSpawnFlags = GSpawnFlags::DEFAULT;
pub const G_SPAWN_LEAVE_DESCRIPTORS_OPEN: GSpawnFlags = GSpawnFlags::LEAVE_DESCRIPTORS_OPEN;
pub const G_SPAWN_DO_NOT_REAP_CHILD: GSpawnFlags = GSpawnFlags::DO_NOT_REAP_CHILD;
pub const G_SPAWN_SEARCH_PATH: GSpawnFlags = GSpawnFlags::SEARCH_PATH;
pub const G_SPAWN_STDOUT_TO_DEV_NULL: GSpawnFlags = GSpawnFlags::STDOUT_TO_DEV_NULL;
pub const G_SPAWN_STDERR_TO_DEV_NULL: GSpawnFlags = GSpawnFlags::STDERR_TO_DEV_NULL;
pub const G_SPAWN_CHILD_INHERITS_STDIN: GSpawnFlags = GSpawnFlags::CHILD_INHERITS_STDIN;
pub const G_SPAWN_FILE_AND_ARGV_ZERO: GSpawnFlags = GSpawnFlags::FILE_AND_ARGV_ZERO;
pub const G_SPAWN_SEARCH_PATH_FROM_ENVP: GSpawnFlags = GSpawnFlags::SEARCH_PATH_FROM_ENVP;
pub const G_SPAWN_CLOEXEC_PIPES: GSpawnFlags = GSpawnFlags::CLOEXEC_PIPES;

bitflags! {
    #[repr(C)]
    pub struct GTestSubprocessFlags: c_uint {
        const STDIN = 1;
        const STDOUT = 2;
        const STDERR = 4;
    }
}
pub const G_TEST_SUBPROCESS_INHERIT_STDIN: GTestSubprocessFlags = GTestSubprocessFlags::STDIN;
pub const G_TEST_SUBPROCESS_INHERIT_STDOUT: GTestSubprocessFlags = GTestSubprocessFlags::STDOUT;
pub const G_TEST_SUBPROCESS_INHERIT_STDERR: GTestSubprocessFlags = GTestSubprocessFlags::STDERR;

bitflags! {
    #[repr(C)]
    pub struct GTestTrapFlags: c_uint {
        const SILENCE_STDOUT = 128;
        const SILENCE_STDERR = 256;
        const INHERIT_STDIN = 512;
    }
}
pub const G_TEST_TRAP_SILENCE_STDOUT: GTestTrapFlags = GTestTrapFlags::SILENCE_STDOUT;
pub const G_TEST_TRAP_SILENCE_STDERR: GTestTrapFlags = GTestTrapFlags::SILENCE_STDERR;
pub const G_TEST_TRAP_INHERIT_STDIN: GTestTrapFlags = GTestTrapFlags::INHERIT_STDIN;

bitflags! {
    #[repr(C)]
    pub struct GTraverseFlags: c_uint {
        const LEAVES = 1;
        const NON_LEAVES = 2;
        const ALL = 3;
        const MASK = 3;
        const LEAFS = 1;
        const NON_LEAFS = 2;
    }
}
pub const G_TRAVERSE_LEAVES: GTraverseFlags = GTraverseFlags::LEAFS;
pub const G_TRAVERSE_NON_LEAVES: GTraverseFlags = GTraverseFlags::NON_LEAFS;
pub const G_TRAVERSE_ALL: GTraverseFlags = GTraverseFlags::MASK;
pub const G_TRAVERSE_MASK: GTraverseFlags = GTraverseFlags::MASK;
pub const G_TRAVERSE_LEAFS: GTraverseFlags = GTraverseFlags::LEAFS;
pub const G_TRAVERSE_NON_LEAFS: GTraverseFlags = GTraverseFlags::NON_LEAFS;

// Unions
pub type GDoubleIEEE754 = c_void; // union
pub type GFloatIEEE754 = c_void; // union
#[cfg(target_pointer_width = "32")]
#[repr(C)]
#[derive(Debug)]
pub struct GMutex([u32; 2]);
#[cfg(target_pointer_width = "64")]
#[repr(C)]
#[derive(Debug)]
pub struct GMutex(*mut c_void);
pub type GTokenValue = c_void; // union

// Callbacks
pub type GChildWatchFunc = Option<unsafe extern "C" fn(GPid, c_int, gpointer)>;
pub type GCompareDataFunc = Option<unsafe extern "C" fn(gconstpointer, gconstpointer, gpointer) -> c_int>;
pub type GCompareFunc = Option<unsafe extern "C" fn(gconstpointer, gconstpointer) -> c_int>;
pub type GCopyFunc = Option<unsafe extern "C" fn(gconstpointer, gpointer) -> gpointer>;
pub type GDataForeachFunc = Option<unsafe extern "C" fn(GQuark, gpointer, gpointer)>;
pub type GDestroyNotify = Option<unsafe extern "C" fn(gpointer)>;
pub type GDuplicateFunc = Option<unsafe extern "C" fn(gpointer, gpointer) -> gpointer>;
pub type GEqualFunc = Option<unsafe extern "C" fn(gconstpointer, gconstpointer) -> gboolean>;
pub type GFreeFunc = Option<unsafe extern "C" fn(gpointer)>;
pub type GFunc = Option<unsafe extern "C" fn(gpointer, gpointer)>;
pub type GHFunc = Option<unsafe extern "C" fn(gpointer, gpointer, gpointer)>;
pub type GHRFunc = Option<unsafe extern "C" fn(gpointer, gpointer, gpointer) -> gboolean>;
pub type GHashFunc = Option<unsafe extern "C" fn(gconstpointer) -> c_uint>;
pub type GHookCheckFunc = Option<unsafe extern "C" fn(gpointer) -> gboolean>;
pub type GHookCheckMarshaller = Option<unsafe extern "C" fn(*mut GHook, gpointer) -> gboolean>;
pub type GHookCompareFunc = Option<unsafe extern "C" fn(*mut GHook, *mut GHook) -> c_int>;
pub type GHookFinalizeFunc = Option<unsafe extern "C" fn(*mut GHookList, *mut GHook)>;
pub type GHookFindFunc = Option<unsafe extern "C" fn(*mut GHook, gpointer) -> gboolean>;
pub type GHookFunc = Option<unsafe extern "C" fn(gpointer)>;
pub type GHookMarshaller = Option<unsafe extern "C" fn(*mut GHook, gpointer)>;
pub type GIOFunc = Option<unsafe extern "C" fn(*mut GIOChannel, GIOCondition, gpointer) -> gboolean>;
pub type GLogFunc = Option<unsafe extern "C" fn(*const c_char, GLogLevelFlags, *const c_char, gpointer)>;
pub type GLogWriterFunc = Option<unsafe extern "C" fn(GLogLevelFlags, *mut GLogField, size_t, gpointer) -> GLogWriterOutput>;
pub type GNodeForeachFunc = Option<unsafe extern "C" fn(*mut GNode, gpointer)>;
pub type GNodeTraverseFunc = Option<unsafe extern "C" fn(*mut GNode, gpointer) -> gboolean>;
pub type GOptionArgFunc = Option<unsafe extern "C" fn(*const c_char, *const c_char, gpointer, *mut *mut GError) -> gboolean>;
pub type GOptionErrorFunc = Option<unsafe extern "C" fn(*mut GOptionContext, *mut GOptionGroup, gpointer, *mut *mut GError)>;
pub type GOptionParseFunc = Option<unsafe extern "C" fn(*mut GOptionContext, *mut GOptionGroup, gpointer, *mut *mut GError) -> gboolean>;
pub type GPollFunc = Option<unsafe extern "C" fn(*mut GPollFD, c_uint, c_int) -> c_int>;
pub type GPrintFunc = Option<unsafe extern "C" fn(*const c_char)>;
pub type GRegexEvalCallback = Option<unsafe extern "C" fn(*const GMatchInfo, *mut GString, gpointer) -> gboolean>;
pub type GScannerMsgFunc = Option<unsafe extern "C" fn(*mut GScanner, *mut c_char, gboolean)>;
pub type GSequenceIterCompareFunc = Option<unsafe extern "C" fn(*mut GSequenceIter, *mut GSequenceIter, gpointer) -> c_int>;
pub type GSourceDummyMarshal = Option<unsafe extern "C" fn()>;
pub type GSourceFunc = Option<unsafe extern "C" fn(gpointer) -> gboolean>;
pub type GSpawnChildSetupFunc = Option<unsafe extern "C" fn(gpointer)>;
pub type GTestDataFunc = Option<unsafe extern "C" fn(gconstpointer)>;
pub type GTestFixtureFunc = Option<unsafe extern "C" fn(gpointer, gconstpointer)>;
pub type GTestFunc = Option<unsafe extern "C" fn()>;
pub type GTestLogFatalFunc = Option<unsafe extern "C" fn(*const c_char, GLogLevelFlags, *const c_char, gpointer) -> gboolean>;
pub type GThreadFunc = Option<unsafe extern "C" fn(gpointer) -> gpointer>;
pub type GTranslateFunc = Option<unsafe extern "C" fn(*const c_char, gpointer) -> *const c_char>;
pub type GTraverseFunc = Option<unsafe extern "C" fn(gpointer, gpointer, gpointer) -> gboolean>;
pub type GUnixFDSourceFunc = Option<unsafe extern "C" fn(c_int, GIOCondition, gpointer) -> gboolean>;
pub type GVoidFunc = Option<unsafe extern "C" fn()>;

// Records
#[repr(C)]
pub struct GArray {
    pub data: *mut c_char,
    pub len: c_uint,
}

impl ::std::fmt::Debug for GArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GArray @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GAsyncQueue(c_void);

impl ::std::fmt::Debug for GAsyncQueue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GAsyncQueue @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GBookmarkFile(c_void);

impl ::std::fmt::Debug for GBookmarkFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GBookmarkFile @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GByteArray {
    pub data: *mut u8,
    pub len: c_uint,
}

impl ::std::fmt::Debug for GByteArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GByteArray @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GBytes(c_void);

impl ::std::fmt::Debug for GBytes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GBytes @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GChecksum(c_void);

impl ::std::fmt::Debug for GChecksum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GChecksum @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GCond {
    pub p: gpointer,
    pub i: [c_uint; 2],
}

impl ::std::fmt::Debug for GCond {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GCond @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GData(c_void);

impl ::std::fmt::Debug for GData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GData @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GDate {
    _truncated_record_marker: c_void,
    //julian_days: guint: 32,
    //julian: guint: 1,
    //dmy: guint: 1,
    //day: guint: 6,
    //month: guint: 4,
    //year: guint: 16,
}

impl ::std::fmt::Debug for GDate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GDate @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GDateTime(c_void);

impl ::std::fmt::Debug for GDateTime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GDateTime @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GDebugKey {
    pub key: *const c_char,
    pub value: c_uint,
}

impl ::std::fmt::Debug for GDebugKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GDebugKey @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GDir(c_void);

impl ::std::fmt::Debug for GDir {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GDir @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GError {
    pub domain: GQuark,
    pub code: c_int,
    pub message: *mut c_char,
}

impl ::std::fmt::Debug for GError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GError @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GHashTable(c_void);

impl ::std::fmt::Debug for GHashTable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GHashTable @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GHashTableIter {
    pub dummy1: gpointer,
    pub dummy2: gpointer,
    pub dummy3: gpointer,
    pub dummy4: c_int,
    pub dummy5: gboolean,
    pub dummy6: gpointer,
}

impl ::std::fmt::Debug for GHashTableIter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GHashTableIter @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GHmac(c_void);

impl ::std::fmt::Debug for GHmac {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GHmac @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GHook {
    pub data: gpointer,
    pub next: *mut GHook,
    pub prev: *mut GHook,
    pub ref_count: c_uint,
    pub hook_id: c_ulong,
    pub flags: c_uint,
    pub func: gpointer,
    pub destroy: GDestroyNotify,
}

impl ::std::fmt::Debug for GHook {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GHook @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GHookList {
    pub seq_id: c_ulong,
    #[cfg(any(not(windows), not(target_pointer_width = "64")))]
    pub hook_size_and_setup: gpointer,
    #[cfg(all(windows, target_pointer_width = "64"))]
    pub hook_size_and_setup: c_ulong,
    pub hooks: *mut GHook,
    pub dummy3: gpointer,
    pub finalize_hook: GHookFinalizeFunc,
    pub dummy: [gpointer; 2],
}

impl ::std::fmt::Debug for GHookList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GHookList @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GIConv(c_void);

impl ::std::fmt::Debug for GIConv {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GIConv @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GIOChannel {
    pub ref_count: c_int,
    pub funcs: *mut GIOFuncs,
    pub encoding: *mut c_char,
    pub read_cd: GIConv,
    pub write_cd: GIConv,
    pub line_term: *mut c_char,
    pub line_term_len: c_uint,
    pub buf_size: size_t,
    pub read_buf: *mut GString,
    pub encoded_read_buf: *mut GString,
    pub write_buf: *mut GString,
    pub partial_write_buf: [c_char; 6],
    _truncated_record_marker: c_void,
    //use_buffer: guint: 1,
    //do_encode: guint: 1,
    //close_on_unref: guint: 1,
    //is_readable: guint: 1,
    //is_writeable: guint: 1,
    //is_seekable: guint: 1,
    //reserved1: gpointer,
    //reserved2: gpointer,
}

impl ::std::fmt::Debug for GIOChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GIOChannel @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GIOFuncs {
    pub io_read: Option<unsafe extern "C" fn(*mut GIOChannel, *const c_char, size_t, *mut size_t, *mut *mut GError) -> GIOStatus>,
    pub io_write: Option<unsafe extern "C" fn(*mut GIOChannel, *const c_char, size_t, *mut size_t, *mut *mut GError) -> GIOStatus>,
    pub io_seek: Option<unsafe extern "C" fn(*mut GIOChannel, i64, GSeekType, *mut *mut GError) -> GIOStatus>,
    pub io_close: Option<unsafe extern "C" fn(*mut GIOChannel, *mut *mut GError) -> GIOStatus>,
    pub io_create_watch: Option<unsafe extern "C" fn(*mut GIOChannel, GIOCondition) -> *mut GSource>,
    pub io_free: Option<unsafe extern "C" fn(*mut GIOChannel)>,
    pub io_set_flags: Option<unsafe extern "C" fn(*mut GIOChannel, GIOFlags, *mut *mut GError) -> GIOStatus>,
    pub io_get_flags: Option<unsafe extern "C" fn(*mut GIOChannel) -> GIOFlags>,
}

impl ::std::fmt::Debug for GIOFuncs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GIOFuncs @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GKeyFile(c_void);

impl ::std::fmt::Debug for GKeyFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GKeyFile @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GList {
    pub data: gpointer,
    pub next: *mut GList,
    pub prev: *mut GList,
}

impl ::std::fmt::Debug for GList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GList @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GLogField {
    pub key: *const c_char,
    pub value: gconstpointer,
    pub length: ssize_t,
}

impl ::std::fmt::Debug for GLogField {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GLogField @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GMainContext(c_void);

impl ::std::fmt::Debug for GMainContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GMainContext @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GMainLoop(c_void);

impl ::std::fmt::Debug for GMainLoop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GMainLoop @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GMappedFile(c_void);

impl ::std::fmt::Debug for GMappedFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GMappedFile @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GMarkupParseContext(c_void);

impl ::std::fmt::Debug for GMarkupParseContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GMarkupParseContext @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GMarkupParser {
    pub start_element: Option<unsafe extern "C" fn(*mut GMarkupParseContext, *const c_char, *mut *const c_char, *mut *const c_char, gpointer, *mut *mut GError)>,
    pub end_element: Option<unsafe extern "C" fn(*mut GMarkupParseContext, *const c_char, gpointer, *mut *mut GError)>,
    pub text: Option<unsafe extern "C" fn(*mut GMarkupParseContext, *const c_char, size_t, gpointer, *mut *mut GError)>,
    pub passthrough: Option<unsafe extern "C" fn(*mut GMarkupParseContext, *const c_char, size_t, gpointer, *mut *mut GError)>,
    pub error: Option<unsafe extern "C" fn(*mut GMarkupParseContext, *mut GError, gpointer)>,
}

impl ::std::fmt::Debug for GMarkupParser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GMarkupParser @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GMatchInfo(c_void);

impl ::std::fmt::Debug for GMatchInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GMatchInfo @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GMemVTable {
    pub malloc: Option<unsafe extern "C" fn(size_t) -> gpointer>,
    pub realloc: Option<unsafe extern "C" fn(gpointer, size_t) -> gpointer>,
    pub free: Option<unsafe extern "C" fn(gpointer)>,
    pub calloc: Option<unsafe extern "C" fn(size_t, size_t) -> gpointer>,
    pub try_malloc: Option<unsafe extern "C" fn(size_t) -> gpointer>,
    pub try_realloc: Option<unsafe extern "C" fn(gpointer, size_t) -> gpointer>,
}

impl ::std::fmt::Debug for GMemVTable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GMemVTable @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GNode {
    pub data: gpointer,
    pub next: *mut GNode,
    pub prev: *mut GNode,
    pub parent: *mut GNode,
    pub children: *mut GNode,
}

impl ::std::fmt::Debug for GNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GNode @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GOnce {
    pub status: Volatile<GOnceStatus>,
    pub retval: Volatile<gpointer>,
}

impl ::std::fmt::Debug for GOnce {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GOnce @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GOptionContext(c_void);

impl ::std::fmt::Debug for GOptionContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GOptionContext @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GOptionEntry {
    pub long_name: *const c_char,
    pub short_name: c_char,
    pub flags: c_int,
    pub arg: GOptionArg,
    pub arg_data: gpointer,
    pub description: *const c_char,
    pub arg_description: *const c_char,
}

impl ::std::fmt::Debug for GOptionEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GOptionEntry @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GOptionGroup(c_void);

impl ::std::fmt::Debug for GOptionGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GOptionGroup @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GPatternSpec(c_void);

impl ::std::fmt::Debug for GPatternSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GPatternSpec @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GPollFD {
    pub fd: c_int,
    pub events: c_ushort,
    pub revents: c_ushort,
}

impl ::std::fmt::Debug for GPollFD {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GPollFD @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GPrivate {
    pub p: gpointer,
    pub notify: GDestroyNotify,
    pub future: [gpointer; 2],
}

impl ::std::fmt::Debug for GPrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GPrivate @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GPtrArray {
    pub pdata: *mut gpointer,
    pub len: c_uint,
}

impl ::std::fmt::Debug for GPtrArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GPtrArray @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GQueue {
    pub head: *mut GList,
    pub tail: *mut GList,
    pub length: c_uint,
}

impl ::std::fmt::Debug for GQueue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GQueue @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GRWLock {
    pub p: gpointer,
    pub i: [c_uint; 2],
}

impl ::std::fmt::Debug for GRWLock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GRWLock @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GRand(c_void);

impl ::std::fmt::Debug for GRand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GRand @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GRecMutex {
    pub p: gpointer,
    pub i: [c_uint; 2],
}

impl ::std::fmt::Debug for GRecMutex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GRecMutex @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GRegex(c_void);

impl ::std::fmt::Debug for GRegex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GRegex @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GSList {
    pub data: gpointer,
    pub next: *mut GSList,
}

impl ::std::fmt::Debug for GSList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GSList @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GScanner {
    pub user_data: gpointer,
    pub max_parse_errors: c_uint,
    pub parse_errors: c_uint,
    pub input_name: *const c_char,
    pub qdata: *mut GData,
    pub config: *mut GScannerConfig,
    pub token: GTokenType,
    _truncated_record_marker: c_void,
    //union,
    //line: guint,
    //position: guint,
    //next_token: GTokenType,
    //union,
    //next_line: guint,
    //next_position: guint,
    //symbol_table: GHashTable*,
    //input_fd: gint,
    //text: const gchar*,
    //text_end: const gchar*,
    //buffer: gchar*,
    //scope_id: guint,
    //msg_handler: GScannerMsgFunc,
}

impl ::std::fmt::Debug for GScanner {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GScanner @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GScannerConfig {
    pub cset_skip_characters: *mut c_char,
    pub cset_identifier_first: *mut c_char,
    pub cset_identifier_nth: *mut c_char,
    pub cpair_comment_single: *mut c_char,
    _truncated_record_marker: c_void,
    //case_sensitive: guint: 1,
    //skip_comment_multi: guint: 1,
    //skip_comment_single: guint: 1,
    //scan_comment_multi: guint: 1,
    //scan_identifier: guint: 1,
    //scan_identifier_1char: guint: 1,
    //scan_identifier_NULL: guint: 1,
    //scan_symbols: guint: 1,
    //scan_binary: guint: 1,
    //scan_octal: guint: 1,
    //scan_float: guint: 1,
    //scan_hex: guint: 1,
    //scan_hex_dollar: guint: 1,
    //scan_string_sq: guint: 1,
    //scan_string_dq: guint: 1,
    //numbers_2_int: guint: 1,
    //int_2_float: guint: 1,
    //identifier_2_string: guint: 1,
    //char_2_token: guint: 1,
    //symbol_2_token: guint: 1,
    //scope_0_fallback: guint: 1,
    //store_int64: guint: 1,
    //padding_dummy: guint,
}

impl ::std::fmt::Debug for GScannerConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GScannerConfig @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GSequence(c_void);

impl ::std::fmt::Debug for GSequence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GSequence @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GSequenceIter(c_void);

impl ::std::fmt::Debug for GSequenceIter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GSequenceIter @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GSource {
    pub callback_data: gpointer,
    pub callback_funcs: *mut GSourceCallbackFuncs,
    pub source_funcs: *const GSourceFuncs,
    pub ref_count: c_uint,
    pub context: *mut GMainContext,
    pub priority: c_int,
    pub flags: c_uint,
    pub source_id: c_uint,
    pub poll_fds: *mut GSList,
    pub prev: *mut GSource,
    pub next: *mut GSource,
    pub name: *mut c_char,
    pub priv_: *mut GSourcePrivate,
}

impl ::std::fmt::Debug for GSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GSource @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GSourceCallbackFuncs {
    pub ref_: Option<unsafe extern "C" fn(gpointer)>,
    pub unref: Option<unsafe extern "C" fn(gpointer)>,
    pub get: Option<unsafe extern "C" fn(gpointer, *mut GSource, *mut GSourceFunc, *mut gpointer)>,
}

impl ::std::fmt::Debug for GSourceCallbackFuncs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GSourceCallbackFuncs @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GSourceFuncs {
    pub prepare: Option<unsafe extern "C" fn(*mut GSource, *mut c_int) -> gboolean>,
    pub check: Option<unsafe extern "C" fn(*mut GSource) -> gboolean>,
    pub dispatch: Option<unsafe extern "C" fn(*mut GSource, GSourceFunc, gpointer) -> gboolean>,
    pub finalize: Option<unsafe extern "C" fn(*mut GSource)>,
    pub closure_callback: GSourceFunc,
    pub closure_marshal: GSourceDummyMarshal,
}

impl ::std::fmt::Debug for GSourceFuncs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GSourceFuncs @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GSourcePrivate(c_void);

impl ::std::fmt::Debug for GSourcePrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GSourcePrivate @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GStatBuf(c_void);

impl ::std::fmt::Debug for GStatBuf {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GStatBuf @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GString {
    pub str: *mut c_char,
    pub len: size_t,
    pub allocated_len: size_t,
}

impl ::std::fmt::Debug for GString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GString @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GStringChunk(c_void);

impl ::std::fmt::Debug for GStringChunk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GStringChunk @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GTestCase(c_void);

impl ::std::fmt::Debug for GTestCase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GTestCase @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GTestConfig {
    pub test_initialized: gboolean,
    pub test_quick: gboolean,
    pub test_perf: gboolean,
    pub test_verbose: gboolean,
    pub test_quiet: gboolean,
    pub test_undefined: gboolean,
}

impl ::std::fmt::Debug for GTestConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GTestConfig @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GTestLogBuffer {
    pub data: *mut GString,
    pub msgs: *mut GSList,
}

impl ::std::fmt::Debug for GTestLogBuffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GTestLogBuffer @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GTestLogMsg {
    pub log_type: GTestLogType,
    pub n_strings: c_uint,
    pub strings: *mut *mut c_char,
    pub n_nums: c_uint,
    pub nums: *mut c_long,
}

impl ::std::fmt::Debug for GTestLogMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GTestLogMsg @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GTestSuite(c_void);

impl ::std::fmt::Debug for GTestSuite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GTestSuite @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GThread(c_void);

impl ::std::fmt::Debug for GThread {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GThread @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GThreadPool {
    pub func: GFunc,
    pub user_data: gpointer,
    pub exclusive: gboolean,
}

impl ::std::fmt::Debug for GThreadPool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GThreadPool @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GTimeVal {
    pub tv_sec: c_long,
    pub tv_usec: c_long,
}

impl ::std::fmt::Debug for GTimeVal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GTimeVal @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GTimeZone(c_void);

impl ::std::fmt::Debug for GTimeZone {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GTimeZone @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GTimer(c_void);

impl ::std::fmt::Debug for GTimer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GTimer @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GTrashStack {
    pub next: *mut GTrashStack,
}

impl ::std::fmt::Debug for GTrashStack {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GTrashStack @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GTree(c_void);

impl ::std::fmt::Debug for GTree {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GTree @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GVariant(c_void);

impl ::std::fmt::Debug for GVariant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GVariant @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GVariantBuilder {
    _truncated_record_marker: c_void,
    //union,
}

impl ::std::fmt::Debug for GVariantBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GVariantBuilder @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GVariantDict {
    _truncated_record_marker: c_void,
    //union,
}

impl ::std::fmt::Debug for GVariantDict {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GVariantDict @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GVariantIter {
    pub x: [size_t; 16],
}

impl ::std::fmt::Debug for GVariantIter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GVariantIter @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GVariantType(c_void);

impl ::std::fmt::Debug for GVariantType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GVariantType @ {:?}", self as *const _)
    }
}

extern "C" {

    //=========================================================================
    // GIOCondition
    //=========================================================================
    pub fn g_io_condition_get_type() -> GType;

    //=========================================================================
    // GMutex
    //=========================================================================
    pub fn g_mutex_clear(mutex: *mut GMutex);
    pub fn g_mutex_init(mutex: *mut GMutex);
    pub fn g_mutex_lock(mutex: *mut GMutex);
    pub fn g_mutex_trylock(mutex: *mut GMutex) -> gboolean;
    pub fn g_mutex_unlock(mutex: *mut GMutex);

    //=========================================================================
    // GArray
    //=========================================================================
    pub fn g_array_get_type() -> GType;
    pub fn g_array_append_vals(array: *mut GArray, data: gconstpointer, len: c_uint) -> *mut GArray;
    pub fn g_array_free(array: *mut GArray, free_segment: gboolean) -> *mut c_char;
    pub fn g_array_get_element_size(array: *mut GArray) -> c_uint;
    pub fn g_array_insert_vals(array: *mut GArray, index_: c_uint, data: gconstpointer, len: c_uint) -> *mut GArray;
    pub fn g_array_new(zero_terminated: gboolean, clear_: gboolean, element_size: c_uint) -> *mut GArray;
    pub fn g_array_prepend_vals(array: *mut GArray, data: gconstpointer, len: c_uint) -> *mut GArray;
    pub fn g_array_ref(array: *mut GArray) -> *mut GArray;
    pub fn g_array_remove_index(array: *mut GArray, index_: c_uint) -> *mut GArray;
    pub fn g_array_remove_index_fast(array: *mut GArray, index_: c_uint) -> *mut GArray;
    pub fn g_array_remove_range(array: *mut GArray, index_: c_uint, length: c_uint) -> *mut GArray;
    pub fn g_array_set_clear_func(array: *mut GArray, clear_func: GDestroyNotify);
    pub fn g_array_set_size(array: *mut GArray, length: c_uint) -> *mut GArray;
    pub fn g_array_sized_new(zero_terminated: gboolean, clear_: gboolean, element_size: c_uint, reserved_size: c_uint) -> *mut GArray;
    pub fn g_array_sort(array: *mut GArray, compare_func: GCompareFunc);
    pub fn g_array_sort_with_data(array: *mut GArray, compare_func: GCompareDataFunc, user_data: gpointer);
    pub fn g_array_unref(array: *mut GArray);

    //=========================================================================
    // GAsyncQueue
    //=========================================================================
    pub fn g_async_queue_length(queue: *mut GAsyncQueue) -> c_int;
    pub fn g_async_queue_length_unlocked(queue: *mut GAsyncQueue) -> c_int;
    pub fn g_async_queue_lock(queue: *mut GAsyncQueue);
    pub fn g_async_queue_pop(queue: *mut GAsyncQueue) -> gpointer;
    pub fn g_async_queue_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
    pub fn g_async_queue_push(queue: *mut GAsyncQueue, data: gpointer);
    #[cfg(any(feature = "v2_46", feature = "dox"))]
    pub fn g_async_queue_push_front(queue: *mut GAsyncQueue, item: gpointer);
    #[cfg(any(feature = "v2_46", feature = "dox"))]
    pub fn g_async_queue_push_front_unlocked(queue: *mut GAsyncQueue, item: gpointer);
    pub fn g_async_queue_push_sorted(queue: *mut GAsyncQueue, data: gpointer, func: GCompareDataFunc, user_data: gpointer);
    pub fn g_async_queue_push_sorted_unlocked(queue: *mut GAsyncQueue, data: gpointer, func: GCompareDataFunc, user_data: gpointer);
    pub fn g_async_queue_push_unlocked(queue: *mut GAsyncQueue, data: gpointer);
    pub fn g_async_queue_ref(queue: *mut GAsyncQueue) -> *mut GAsyncQueue;
    pub fn g_async_queue_ref_unlocked(queue: *mut GAsyncQueue);
    #[cfg(any(feature = "v2_46", feature = "dox"))]
    pub fn g_async_queue_remove(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
    #[cfg(any(feature = "v2_46", feature = "dox"))]
    pub fn g_async_queue_remove_unlocked(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
    pub fn g_async_queue_sort(queue: *mut GAsyncQueue, func: GCompareDataFunc, user_data: gpointer);
    pub fn g_async_queue_sort_unlocked(queue: *mut GAsyncQueue, func: GCompareDataFunc, user_data: gpointer);
    pub fn g_async_queue_timed_pop(queue: *mut GAsyncQueue, end_time: *mut GTimeVal) -> gpointer;
    pub fn g_async_queue_timed_pop_unlocked(queue: *mut GAsyncQueue, end_time: *mut GTimeVal) -> gpointer;
    pub fn g_async_queue_timeout_pop(queue: *mut GAsyncQueue, timeout: u64) -> gpointer;
    pub fn g_async_queue_timeout_pop_unlocked(queue: *mut GAsyncQueue, timeout: u64) -> gpointer;
    pub fn g_async_queue_try_pop(queue: *mut GAsyncQueue) -> gpointer;
    pub fn g_async_queue_try_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
    pub fn g_async_queue_unlock(queue: *mut GAsyncQueue);
    pub fn g_async_queue_unref(queue: *mut GAsyncQueue);
    pub fn g_async_queue_unref_and_unlock(queue: *mut GAsyncQueue);
    pub fn g_async_queue_new() -> *mut GAsyncQueue;
    pub fn g_async_queue_new_full(item_free_func: GDestroyNotify) -> *mut GAsyncQueue;

    //=========================================================================
    // GBookmarkFile
    //=========================================================================
    pub fn g_bookmark_file_add_application(bookmark: *mut GBookmarkFile, uri: *const c_char, name: *const c_char, exec: *const c_char);
    pub fn g_bookmark_file_add_group(bookmark: *mut GBookmarkFile, uri: *const c_char, group: *const c_char);
    pub fn g_bookmark_file_free(bookmark: *mut GBookmarkFile);
    pub fn g_bookmark_file_get_added(bookmark: *mut GBookmarkFile, uri: *const c_char, error: *mut *mut GError) -> c_long;
    pub fn g_bookmark_file_get_app_info(bookmark: *mut GBookmarkFile, uri: *const c_char, name: *const c_char, exec: *mut *mut c_char, count: *mut c_uint, stamp: *mut c_long, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_get_applications(bookmark: *mut GBookmarkFile, uri: *const c_char, length: *mut size_t, error: *mut *mut GError) -> *mut *mut c_char;
    pub fn g_bookmark_file_get_description(bookmark: *mut GBookmarkFile, uri: *const c_char, error: *mut *mut GError) -> *mut c_char;
    pub fn g_bookmark_file_get_groups(bookmark: *mut GBookmarkFile, uri: *const c_char, length: *mut size_t, error: *mut *mut GError) -> *mut *mut c_char;
    pub fn g_bookmark_file_get_icon(bookmark: *mut GBookmarkFile, uri: *const c_char, href: *mut *mut c_char, mime_type: *mut *mut c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_get_is_private(bookmark: *mut GBookmarkFile, uri: *const c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_get_mime_type(bookmark: *mut GBookmarkFile, uri: *const c_char, error: *mut *mut GError) -> *mut c_char;
    pub fn g_bookmark_file_get_modified(bookmark: *mut GBookmarkFile, uri: *const c_char, error: *mut *mut GError) -> c_long;
    pub fn g_bookmark_file_get_size(bookmark: *mut GBookmarkFile) -> c_int;
    pub fn g_bookmark_file_get_title(bookmark: *mut GBookmarkFile, uri: *const c_char, error: *mut *mut GError) -> *mut c_char;
    pub fn g_bookmark_file_get_uris(bookmark: *mut GBookmarkFile, length: *mut size_t) -> *mut *mut c_char;
    pub fn g_bookmark_file_get_visited(bookmark: *mut GBookmarkFile, uri: *const c_char, error: *mut *mut GError) -> c_long;
    pub fn g_bookmark_file_has_application(bookmark: *mut GBookmarkFile, uri: *const c_char, name: *const c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_has_group(bookmark: *mut GBookmarkFile, uri: *const c_char, group: *const c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_has_item(bookmark: *mut GBookmarkFile, uri: *const c_char) -> gboolean;
    pub fn g_bookmark_file_load_from_data(bookmark: *mut GBookmarkFile, data: *const c_char, length: size_t, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_load_from_data_dirs(bookmark: *mut GBookmarkFile, file: *mut c_char, full_path: *mut *mut c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_load_from_file(bookmark: *mut GBookmarkFile, filename: *mut c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_move_item(bookmark: *mut GBookmarkFile, old_uri: *const c_char, new_uri: *const c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_remove_application(bookmark: *mut GBookmarkFile, uri: *const c_char, name: *const c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_remove_group(bookmark: *mut GBookmarkFile, uri: *const c_char, group: *const c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_remove_item(bookmark: *mut GBookmarkFile, uri: *const c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_set_added(bookmark: *mut GBookmarkFile, uri: *const c_char, added: c_long);
    pub fn g_bookmark_file_set_app_info(bookmark: *mut GBookmarkFile, uri: *const c_char, name: *const c_char, exec: *const c_char, count: c_int, stamp: c_long, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_set_description(bookmark: *mut GBookmarkFile, uri: *const c_char, description: *const c_char);
    pub fn g_bookmark_file_set_groups(bookmark: *mut GBookmarkFile, uri: *const c_char, groups: *mut *const c_char, length: size_t);
    pub fn g_bookmark_file_set_icon(bookmark: *mut GBookmarkFile, uri: *const c_char, href: *const c_char, mime_type: *const c_char);
    pub fn g_bookmark_file_set_is_private(bookmark: *mut GBookmarkFile, uri: *const c_char, is_private: gboolean);
    pub fn g_bookmark_file_set_mime_type(bookmark: *mut GBookmarkFile, uri: *const c_char, mime_type: *const c_char);
    pub fn g_bookmark_file_set_modified(bookmark: *mut GBookmarkFile, uri: *const c_char, modified: c_long);
    pub fn g_bookmark_file_set_title(bookmark: *mut GBookmarkFile, uri: *const c_char, title: *const c_char);
    pub fn g_bookmark_file_set_visited(bookmark: *mut GBookmarkFile, uri: *const c_char, visited: c_long);
    pub fn g_bookmark_file_to_data(bookmark: *mut GBookmarkFile, length: *mut size_t, error: *mut *mut GError) -> *mut c_char;
    pub fn g_bookmark_file_to_file(bookmark: *mut GBookmarkFile, filename: *mut c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_error_quark() -> GQuark;
    pub fn g_bookmark_file_new() -> *mut GBookmarkFile;

    //=========================================================================
    // GByteArray
    //=========================================================================
    pub fn g_byte_array_get_type() -> GType;
    pub fn g_byte_array_append(array: *mut GByteArray, data: *const u8, len: c_uint) -> *mut GByteArray;
    pub fn g_byte_array_free(array: *mut GByteArray, free_segment: gboolean) -> *mut u8;
    pub fn g_byte_array_free_to_bytes(array: *mut GByteArray) -> *mut GBytes;
    pub fn g_byte_array_new() -> *mut GByteArray;
    pub fn g_byte_array_new_take(data: *mut u8, len: size_t) -> *mut GByteArray;
    pub fn g_byte_array_prepend(array: *mut GByteArray, data: *const u8, len: c_uint) -> *mut GByteArray;
    pub fn g_byte_array_ref(array: *mut GByteArray) -> *mut GByteArray;
    pub fn g_byte_array_remove_index(array: *mut GByteArray, index_: c_uint) -> *mut GByteArray;
    pub fn g_byte_array_remove_index_fast(array: *mut GByteArray, index_: c_uint) -> *mut GByteArray;
    pub fn g_byte_array_remove_range(array: *mut GByteArray, index_: c_uint, length: c_uint) -> *mut GByteArray;
    pub fn g_byte_array_set_size(array: *mut GByteArray, length: c_uint) -> *mut GByteArray;
    pub fn g_byte_array_sized_new(reserved_size: c_uint) -> *mut GByteArray;
    pub fn g_byte_array_sort(array: *mut GByteArray, compare_func: GCompareFunc);
    pub fn g_byte_array_sort_with_data(array: *mut GByteArray, compare_func: GCompareDataFunc, user_data: gpointer);
    pub fn g_byte_array_unref(array: *mut GByteArray);

    //=========================================================================
    // GBytes
    //=========================================================================
    pub fn g_bytes_get_type() -> GType;
    pub fn g_bytes_new(data: gconstpointer, size: size_t) -> *mut GBytes;
    pub fn g_bytes_new_static(data: gconstpointer, size: size_t) -> *mut GBytes;
    pub fn g_bytes_new_take(data: gpointer, size: size_t) -> *mut GBytes;
    pub fn g_bytes_new_with_free_func(data: gconstpointer, size: size_t, free_func: GDestroyNotify, user_data: gpointer) -> *mut GBytes;
    pub fn g_bytes_compare(bytes1: gconstpointer, bytes2: gconstpointer) -> c_int;
    pub fn g_bytes_equal(bytes1: gconstpointer, bytes2: gconstpointer) -> gboolean;
    pub fn g_bytes_get_data(bytes: *mut GBytes, size: *mut size_t) -> gconstpointer;
    pub fn g_bytes_get_size(bytes: *mut GBytes) -> size_t;
    pub fn g_bytes_hash(bytes: gconstpointer) -> c_uint;
    pub fn g_bytes_new_from_bytes(bytes: *mut GBytes, offset: size_t, length: size_t) -> *mut GBytes;
    pub fn g_bytes_ref(bytes: *mut GBytes) -> *mut GBytes;
    pub fn g_bytes_unref(bytes: *mut GBytes);
    pub fn g_bytes_unref_to_array(bytes: *mut GBytes) -> *mut GByteArray;
    pub fn g_bytes_unref_to_data(bytes: *mut GBytes, size: *mut size_t) -> gpointer;

    //=========================================================================
    // GChecksum
    //=========================================================================
    pub fn g_checksum_get_type() -> GType;
    pub fn g_checksum_new(checksum_type: GChecksumType) -> *mut GChecksum;
    pub fn g_checksum_copy(checksum: *const GChecksum) -> *mut GChecksum;
    pub fn g_checksum_free(checksum: *mut GChecksum);
    pub fn g_checksum_get_digest(checksum: *mut GChecksum, buffer: *mut u8, digest_len: *mut size_t);
    pub fn g_checksum_get_string(checksum: *mut GChecksum) -> *const c_char;
    pub fn g_checksum_reset(checksum: *mut GChecksum);
    pub fn g_checksum_update(checksum: *mut GChecksum, data: *mut u8, length: ssize_t);
    pub fn g_checksum_type_get_length(checksum_type: GChecksumType) -> ssize_t;

    //=========================================================================
    // GCond
    //=========================================================================
    pub fn g_cond_broadcast(cond: *mut GCond);
    pub fn g_cond_clear(cond: *mut GCond);
    pub fn g_cond_init(cond: *mut GCond);
    pub fn g_cond_signal(cond: *mut GCond);
    pub fn g_cond_wait(cond: *mut GCond, mutex: *mut GMutex);
    pub fn g_cond_wait_until(cond: *mut GCond, mutex: *mut GMutex, end_time: i64) -> gboolean;

    //=========================================================================
    // GDate
    //=========================================================================
    pub fn g_date_get_type() -> GType;
    pub fn g_date_new() -> *mut GDate;
    pub fn g_date_new_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> *mut GDate;
    pub fn g_date_new_julian(julian_day: u32) -> *mut GDate;
    pub fn g_date_add_days(date: *mut GDate, n_days: c_uint);
    pub fn g_date_add_months(date: *mut GDate, n_months: c_uint);
    pub fn g_date_add_years(date: *mut GDate, n_years: c_uint);
    pub fn g_date_clamp(date: *mut GDate, min_date: *const GDate, max_date: *const GDate);
    pub fn g_date_clear(date: *mut GDate, n_dates: c_uint);
    pub fn g_date_compare(lhs: *const GDate, rhs: *const GDate) -> c_int;
    pub fn g_date_days_between(date1: *const GDate, date2: *const GDate) -> c_int;
    pub fn g_date_free(date: *mut GDate);
    pub fn g_date_get_day(date: *const GDate) -> GDateDay;
    pub fn g_date_get_day_of_year(date: *const GDate) -> c_uint;
    pub fn g_date_get_iso8601_week_of_year(date: *const GDate) -> c_uint;
    pub fn g_date_get_julian(date: *const GDate) -> u32;
    pub fn g_date_get_monday_week_of_year(date: *const GDate) -> c_uint;
    pub fn g_date_get_month(date: *const GDate) -> GDateMonth;
    pub fn g_date_get_sunday_week_of_year(date: *const GDate) -> c_uint;
    pub fn g_date_get_weekday(date: *const GDate) -> GDateWeekday;
    pub fn g_date_get_year(date: *const GDate) -> GDateYear;
    pub fn g_date_is_first_of_month(date: *const GDate) -> gboolean;
    pub fn g_date_is_last_of_month(date: *const GDate) -> gboolean;
    pub fn g_date_order(date1: *mut GDate, date2: *mut GDate);
    pub fn g_date_set_day(date: *mut GDate, day: GDateDay);
    pub fn g_date_set_dmy(date: *mut GDate, day: GDateDay, month: GDateMonth, y: GDateYear);
    pub fn g_date_set_julian(date: *mut GDate, julian_date: u32);
    pub fn g_date_set_month(date: *mut GDate, month: GDateMonth);
    pub fn g_date_set_parse(date: *mut GDate, str: *const c_char);
    pub fn g_date_set_time(date: *mut GDate, time_: GTime);
    pub fn g_date_set_time_t(date: *mut GDate, timet: c_long);
    pub fn g_date_set_time_val(date: *mut GDate, timeval: *mut GTimeVal);
    pub fn g_date_set_year(date: *mut GDate, year: GDateYear);
    pub fn g_date_subtract_days(date: *mut GDate, n_days: c_uint);
    pub fn g_date_subtract_months(date: *mut GDate, n_months: c_uint);
    pub fn g_date_subtract_years(date: *mut GDate, n_years: c_uint);
    //pub fn g_date_to_struct_tm(date: *const GDate, tm: /*Unimplemented*/*mut tm);
    pub fn g_date_valid(date: *const GDate) -> gboolean;
    pub fn g_date_get_days_in_month(month: GDateMonth, year: GDateYear) -> u8;
    pub fn g_date_get_monday_weeks_in_year(year: GDateYear) -> u8;
    pub fn g_date_get_sunday_weeks_in_year(year: GDateYear) -> u8;
    pub fn g_date_is_leap_year(year: GDateYear) -> gboolean;
    pub fn g_date_strftime(s: *mut c_char, slen: size_t, format: *const c_char, date: *const GDate) -> size_t;
    pub fn g_date_valid_day(day: GDateDay) -> gboolean;
    pub fn g_date_valid_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> gboolean;
    pub fn g_date_valid_julian(julian_date: u32) -> gboolean;
    pub fn g_date_valid_month(month: GDateMonth) -> gboolean;
    pub fn g_date_valid_weekday(weekday: GDateWeekday) -> gboolean;
    pub fn g_date_valid_year(year: GDateYear) -> gboolean;

    //=========================================================================
    // GDateTime
    //=========================================================================
    pub fn g_date_time_get_type() -> GType;
    pub fn g_date_time_new(tz: *mut GTimeZone, year: c_int, month: c_int, day: c_int, hour: c_int, minute: c_int, seconds: c_double) -> *mut GDateTime;
    pub fn g_date_time_new_from_timeval_local(tv: *const GTimeVal) -> *mut GDateTime;
    pub fn g_date_time_new_from_timeval_utc(tv: *const GTimeVal) -> *mut GDateTime;
    pub fn g_date_time_new_from_unix_local(t: i64) -> *mut GDateTime;
    pub fn g_date_time_new_from_unix_utc(t: i64) -> *mut GDateTime;
    pub fn g_date_time_new_local(year: c_int, month: c_int, day: c_int, hour: c_int, minute: c_int, seconds: c_double) -> *mut GDateTime;
    pub fn g_date_time_new_now(tz: *mut GTimeZone) -> *mut GDateTime;
    pub fn g_date_time_new_now_local() -> *mut GDateTime;
    pub fn g_date_time_new_now_utc() -> *mut GDateTime;
    pub fn g_date_time_new_utc(year: c_int, month: c_int, day: c_int, hour: c_int, minute: c_int, seconds: c_double) -> *mut GDateTime;
    pub fn g_date_time_add(datetime: *mut GDateTime, timespan: GTimeSpan) -> *mut GDateTime;
    pub fn g_date_time_add_days(datetime: *mut GDateTime, days: c_int) -> *mut GDateTime;
    pub fn g_date_time_add_full(datetime: *mut GDateTime, years: c_int, months: c_int, days: c_int, hours: c_int, minutes: c_int, seconds: c_double) -> *mut GDateTime;
    pub fn g_date_time_add_hours(datetime: *mut GDateTime, hours: c_int) -> *mut GDateTime;
    pub fn g_date_time_add_minutes(datetime: *mut GDateTime, minutes: c_int) -> *mut GDateTime;
    pub fn g_date_time_add_months(datetime: *mut GDateTime, months: c_int) -> *mut GDateTime;
    pub fn g_date_time_add_seconds(datetime: *mut GDateTime, seconds: c_double) -> *mut GDateTime;
    pub fn g_date_time_add_weeks(datetime: *mut GDateTime, weeks: c_int) -> *mut GDateTime;
    pub fn g_date_time_add_years(datetime: *mut GDateTime, years: c_int) -> *mut GDateTime;
    pub fn g_date_time_difference(end: *mut GDateTime, begin: *mut GDateTime) -> GTimeSpan;
    pub fn g_date_time_format(datetime: *mut GDateTime, format: *const c_char) -> *mut c_char;
    pub fn g_date_time_get_day_of_month(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_day_of_week(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_day_of_year(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_hour(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_microsecond(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_minute(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_month(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_second(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_seconds(datetime: *mut GDateTime) -> c_double;
    pub fn g_date_time_get_timezone_abbreviation(datetime: *mut GDateTime) -> *const c_char;
    pub fn g_date_time_get_utc_offset(datetime: *mut GDateTime) -> GTimeSpan;
    pub fn g_date_time_get_week_numbering_year(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_week_of_year(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_year(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_ymd(datetime: *mut GDateTime, year: *mut c_int, month: *mut c_int, day: *mut c_int);
    pub fn g_date_time_is_daylight_savings(datetime: *mut GDateTime) -> gboolean;
    pub fn g_date_time_ref(datetime: *mut GDateTime) -> *mut GDateTime;
    pub fn g_date_time_to_local(datetime: *mut GDateTime) -> *mut GDateTime;
    pub fn g_date_time_to_timeval(datetime: *mut GDateTime, tv: *mut GTimeVal) -> gboolean;
    pub fn g_date_time_to_timezone(datetime: *mut GDateTime, tz: *mut GTimeZone) -> *mut GDateTime;
    pub fn g_date_time_to_unix(datetime: *mut GDateTime) -> i64;
    pub fn g_date_time_to_utc(datetime: *mut GDateTime) -> *mut GDateTime;
    pub fn g_date_time_unref(datetime: *mut GDateTime);
    pub fn g_date_time_compare(dt1: gconstpointer, dt2: gconstpointer) -> c_int;
    pub fn g_date_time_equal(dt1: gconstpointer, dt2: gconstpointer) -> gboolean;
    pub fn g_date_time_hash(datetime: gconstpointer) -> c_uint;

    //=========================================================================
    // GDir
    //=========================================================================
    pub fn g_dir_close(dir: *mut GDir);
    #[cfg(any(windows, feature = "dox"))]
    pub fn g_dir_read_name_utf8(dir: *mut GDir) -> *mut c_char;
    pub fn g_dir_read_name(dir: *mut GDir) -> *mut c_char;
    pub fn g_dir_rewind(dir: *mut GDir);
    pub fn g_dir_make_tmp(tmpl: *mut c_char, error: *mut *mut GError) -> *mut c_char;
    #[cfg(any(windows, feature = "dox"))]
    pub fn g_dir_open_utf8(path: *const c_char, flags: c_uint, error: *mut *mut GError) -> *mut GDir;
    pub fn g_dir_open(path: *const c_char, flags: c_uint, error: *mut *mut GError) -> *mut GDir;

    //=========================================================================
    // GError
    //=========================================================================
    pub fn g_error_get_type() -> GType;
    pub fn g_error_new(domain: GQuark, code: c_int, format: *const c_char, ...) -> *mut GError;
    pub fn g_error_new_literal(domain: GQuark, code: c_int, message: *const c_char) -> *mut GError;
    //pub fn g_error_new_valist(domain: GQuark, code: c_int, format: *const c_char, args: /*Unimplemented*/va_list) -> *mut GError;
    pub fn g_error_copy(error: *const GError) -> *mut GError;
    pub fn g_error_free(error: *mut GError);
    pub fn g_error_matches(error: *const GError, domain: GQuark, code: c_int) -> gboolean;

    //=========================================================================
    // GHashTable
    //=========================================================================
    pub fn g_hash_table_get_type() -> GType;
    pub fn g_hash_table_add(hash_table: *mut GHashTable, key: gpointer) -> gboolean;
    pub fn g_hash_table_contains(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
    pub fn g_hash_table_destroy(hash_table: *mut GHashTable);
    pub fn g_hash_table_find(hash_table: *mut GHashTable, predicate: GHRFunc, user_data: gpointer) -> gpointer;
    pub fn g_hash_table_foreach(hash_table: *mut GHashTable, func: GHFunc, user_data: gpointer);
    pub fn g_hash_table_foreach_remove(hash_table: *mut GHashTable, func: GHRFunc, user_data: gpointer) -> c_uint;
    pub fn g_hash_table_foreach_steal(hash_table: *mut GHashTable, func: GHRFunc, user_data: gpointer) -> c_uint;
    pub fn g_hash_table_get_keys(hash_table: *mut GHashTable) -> *mut GList;
    #[cfg(any(feature = "v2_40", feature = "dox"))]
    pub fn g_hash_table_get_keys_as_array(hash_table: *mut GHashTable, length: *mut c_uint) -> *mut gpointer;
    pub fn g_hash_table_get_values(hash_table: *mut GHashTable) -> *mut GList;
    pub fn g_hash_table_insert(hash_table: *mut GHashTable, key: gpointer, value: gpointer) -> gboolean;
    pub fn g_hash_table_lookup(hash_table: *mut GHashTable, key: gconstpointer) -> gpointer;
    pub fn g_hash_table_lookup_extended(hash_table: *mut GHashTable, lookup_key: gconstpointer, orig_key: *mut gpointer, value: *mut gpointer) -> gboolean;
    pub fn g_hash_table_new(hash_func: GHashFunc, key_equal_func: GEqualFunc) -> *mut GHashTable;
    pub fn g_hash_table_new_full(hash_func: GHashFunc, key_equal_func: GEqualFunc, key_destroy_func: GDestroyNotify, value_destroy_func: GDestroyNotify) -> *mut GHashTable;
    pub fn g_hash_table_ref(hash_table: *mut GHashTable) -> *mut GHashTable;
    pub fn g_hash_table_remove(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
    pub fn g_hash_table_remove_all(hash_table: *mut GHashTable);
    pub fn g_hash_table_replace(hash_table: *mut GHashTable, key: gpointer, value: gpointer) -> gboolean;
    pub fn g_hash_table_size(hash_table: *mut GHashTable) -> c_uint;
    pub fn g_hash_table_steal(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
    pub fn g_hash_table_steal_all(hash_table: *mut GHashTable);
    pub fn g_hash_table_unref(hash_table: *mut GHashTable);

    //=========================================================================
    // GHashTableIter
    //=========================================================================
    pub fn g_hash_table_iter_get_hash_table(iter: *mut GHashTableIter) -> *mut GHashTable;
    pub fn g_hash_table_iter_init(iter: *mut GHashTableIter, hash_table: *mut GHashTable);
    pub fn g_hash_table_iter_next(iter: *mut GHashTableIter, key: *mut gpointer, value: *mut gpointer) -> gboolean;
    pub fn g_hash_table_iter_remove(iter: *mut GHashTableIter);
    pub fn g_hash_table_iter_replace(iter: *mut GHashTableIter, value: gpointer);
    pub fn g_hash_table_iter_steal(iter: *mut GHashTableIter);

    //=========================================================================
    // GHmac
    //=========================================================================
    pub fn g_hmac_copy(hmac: *const GHmac) -> *mut GHmac;
    pub fn g_hmac_get_digest(hmac: *mut GHmac, buffer: *mut u8, digest_len: *mut size_t);
    pub fn g_hmac_get_string(hmac: *mut GHmac) -> *const c_char;
    pub fn g_hmac_ref(hmac: *mut GHmac) -> *mut GHmac;
    pub fn g_hmac_unref(hmac: *mut GHmac);
    pub fn g_hmac_update(hmac: *mut GHmac, data: *mut u8, length: ssize_t);
    pub fn g_hmac_new(digest_type: GChecksumType, key: *mut u8, key_len: size_t) -> *mut GHmac;

    //=========================================================================
    // GHook
    //=========================================================================
    pub fn g_hook_compare_ids(new_hook: *mut GHook, sibling: *mut GHook) -> c_int;
    pub fn g_hook_alloc(hook_list: *mut GHookList) -> *mut GHook;
    pub fn g_hook_destroy(hook_list: *mut GHookList, hook_id: c_ulong) -> gboolean;
    pub fn g_hook_destroy_link(hook_list: *mut GHookList, hook: *mut GHook);
    pub fn g_hook_find(hook_list: *mut GHookList, need_valids: gboolean, func: GHookFindFunc, data: gpointer) -> *mut GHook;
    pub fn g_hook_find_data(hook_list: *mut GHookList, need_valids: gboolean, data: gpointer) -> *mut GHook;
    pub fn g_hook_find_func(hook_list: *mut GHookList, need_valids: gboolean, func: gpointer) -> *mut GHook;
    pub fn g_hook_find_func_data(hook_list: *mut GHookList, need_valids: gboolean, func: gpointer, data: gpointer) -> *mut GHook;
    pub fn g_hook_first_valid(hook_list: *mut GHookList, may_be_in_call: gboolean) -> *mut GHook;
    pub fn g_hook_free(hook_list: *mut GHookList, hook: *mut GHook);
    pub fn g_hook_get(hook_list: *mut GHookList, hook_id: c_ulong) -> *mut GHook;
    pub fn g_hook_insert_before(hook_list: *mut GHookList, sibling: *mut GHook, hook: *mut GHook);
    pub fn g_hook_insert_sorted(hook_list: *mut GHookList, hook: *mut GHook, func: GHookCompareFunc);
    pub fn g_hook_next_valid(hook_list: *mut GHookList, hook: *mut GHook, may_be_in_call: gboolean) -> *mut GHook;
    pub fn g_hook_prepend(hook_list: *mut GHookList, hook: *mut GHook);
    pub fn g_hook_ref(hook_list: *mut GHookList, hook: *mut GHook) -> *mut GHook;
    pub fn g_hook_unref(hook_list: *mut GHookList, hook: *mut GHook);

    //=========================================================================
    // GHookList
    //=========================================================================
    pub fn g_hook_list_clear(hook_list: *mut GHookList);
    pub fn g_hook_list_init(hook_list: *mut GHookList, hook_size: c_uint);
    pub fn g_hook_list_invoke(hook_list: *mut GHookList, may_recurse: gboolean);
    pub fn g_hook_list_invoke_check(hook_list: *mut GHookList, may_recurse: gboolean);
    pub fn g_hook_list_marshal(hook_list: *mut GHookList, may_recurse: gboolean, marshaller: GHookMarshaller, marshal_data: gpointer);
    pub fn g_hook_list_marshal_check(hook_list: *mut GHookList, may_recurse: gboolean, marshaller: GHookCheckMarshaller, marshal_data: gpointer);

    //=========================================================================
    // GIConv
    //=========================================================================
    pub fn g_iconv_close(converter: GIConv) -> c_int;
    pub fn g_iconv_open(to_codeset: *const c_char, from_codeset: *const c_char) -> GIConv;

    //=========================================================================
    // GIOChannel
    //=========================================================================
    pub fn g_io_channel_get_type() -> GType;
    #[cfg(any(windows, feature = "dox"))]
    pub fn g_io_channel_new_file_utf8(filename: *mut c_char, mode: *const c_char, error: *mut *mut GError) -> *mut GIOChannel;
    pub fn g_io_channel_new_file(filename: *mut c_char, mode: *const c_char, error: *mut *mut GError) -> *mut GIOChannel;
    pub fn g_io_channel_unix_new(fd: c_int) -> *mut GIOChannel;
    pub fn g_io_channel_close(channel: *mut GIOChannel);
    pub fn g_io_channel_flush(channel: *mut GIOChannel, error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_get_buffer_condition(channel: *mut GIOChannel) -> GIOCondition;
    pub fn g_io_channel_get_buffer_size(channel: *mut GIOChannel) -> size_t;
    pub fn g_io_channel_get_buffered(channel: *mut GIOChannel) -> gboolean;
    pub fn g_io_channel_get_close_on_unref(channel: *mut GIOChannel) -> gboolean;
    pub fn g_io_channel_get_encoding(channel: *mut GIOChannel) -> *const c_char;
    pub fn g_io_channel_get_flags(channel: *mut GIOChannel) -> GIOFlags;
    pub fn g_io_channel_get_line_term(channel: *mut GIOChannel, length: *mut c_int) -> *const c_char;
    pub fn g_io_channel_init(channel: *mut GIOChannel);
    pub fn g_io_channel_read(channel: *mut GIOChannel, buf: *mut c_char, count: size_t, bytes_read: *mut size_t) -> GIOError;
    pub fn g_io_channel_read_chars(channel: *mut GIOChannel, buf: *mut u8, count: size_t, bytes_read: *mut size_t, error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_read_line(channel: *mut GIOChannel, str_return: *mut *mut c_char, length: *mut size_t, terminator_pos: *mut size_t, error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_read_line_string(channel: *mut GIOChannel, buffer: *mut GString, terminator_pos: *mut size_t, error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_read_to_end(channel: *mut GIOChannel, str_return: *mut *mut u8, length: *mut size_t, error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_read_unichar(channel: *mut GIOChannel, thechar: *mut u32, error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_ref(channel: *mut GIOChannel) -> *mut GIOChannel;
    pub fn g_io_channel_seek(channel: *mut GIOChannel, offset: i64, type_: GSeekType) -> GIOError;
    pub fn g_io_channel_seek_position(channel: *mut GIOChannel, offset: i64, type_: GSeekType, error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_set_buffer_size(channel: *mut GIOChannel, size: size_t);
    pub fn g_io_channel_set_buffered(channel: *mut GIOChannel, buffered: gboolean);
    pub fn g_io_channel_set_close_on_unref(channel: *mut GIOChannel, do_close: gboolean);
    pub fn g_io_channel_set_encoding(channel: *mut GIOChannel, encoding: *const c_char, error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_set_flags(channel: *mut GIOChannel, flags: GIOFlags, error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_set_line_term(channel: *mut GIOChannel, line_term: *const c_char, length: c_int);
    pub fn g_io_channel_shutdown(channel: *mut GIOChannel, flush: gboolean, error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_unix_get_fd(channel: *mut GIOChannel) -> c_int;
    pub fn g_io_channel_unref(channel: *mut GIOChannel);
    pub fn g_io_channel_write(channel: *mut GIOChannel, buf: *const c_char, count: size_t, bytes_written: *mut size_t) -> GIOError;
    pub fn g_io_channel_write_chars(channel: *mut GIOChannel, buf: *mut u8, count: ssize_t, bytes_written: *mut size_t, error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_write_unichar(channel: *mut GIOChannel, thechar: u32, error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_error_from_errno(en: c_int) -> GIOChannelError;
    pub fn g_io_channel_error_quark() -> GQuark;

    //=========================================================================
    // GKeyFile
    //=========================================================================
    pub fn g_key_file_get_type() -> GType;
    pub fn g_key_file_new() -> *mut GKeyFile;
    pub fn g_key_file_free(key_file: *mut GKeyFile);
    pub fn g_key_file_get_boolean(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_get_boolean_list(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, length: *mut size_t, error: *mut *mut GError) -> *mut gboolean;
    pub fn g_key_file_get_comment(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, error: *mut *mut GError) -> *mut c_char;
    pub fn g_key_file_get_double(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, error: *mut *mut GError) -> c_double;
    pub fn g_key_file_get_double_list(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, length: *mut size_t, error: *mut *mut GError) -> *mut c_double;
    pub fn g_key_file_get_groups(key_file: *mut GKeyFile, length: *mut size_t) -> *mut *mut c_char;
    pub fn g_key_file_get_int64(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, error: *mut *mut GError) -> i64;
    pub fn g_key_file_get_integer(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, error: *mut *mut GError) -> c_int;
    pub fn g_key_file_get_integer_list(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, length: *mut size_t, error: *mut *mut GError) -> *mut c_int;
    pub fn g_key_file_get_keys(key_file: *mut GKeyFile, group_name: *const c_char, length: *mut size_t, error: *mut *mut GError) -> *mut *mut c_char;
    pub fn g_key_file_get_locale_string(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, locale: *const c_char, error: *mut *mut GError) -> *mut c_char;
    pub fn g_key_file_get_locale_string_list(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, locale: *const c_char, length: *mut size_t, error: *mut *mut GError) -> *mut *mut c_char;
    pub fn g_key_file_get_start_group(key_file: *mut GKeyFile) -> *mut c_char;
    pub fn g_key_file_get_string(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, error: *mut *mut GError) -> *mut c_char;
    pub fn g_key_file_get_string_list(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, length: *mut size_t, error: *mut *mut GError) -> *mut *mut c_char;
    pub fn g_key_file_get_uint64(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, error: *mut *mut GError) -> u64;
    pub fn g_key_file_get_value(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, error: *mut *mut GError) -> *mut c_char;
    pub fn g_key_file_has_group(key_file: *mut GKeyFile, group_name: *const c_char) -> gboolean;
    pub fn g_key_file_has_key(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, error: *mut *mut GError) -> gboolean;
    #[cfg(any(feature = "v2_50", feature = "dox"))]
    pub fn g_key_file_load_from_bytes(key_file: *mut GKeyFile, bytes: *mut GBytes, flags: GKeyFileFlags, error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_load_from_data(key_file: *mut GKeyFile, data: *const c_char, length: size_t, flags: GKeyFileFlags, error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_load_from_data_dirs(key_file: *mut GKeyFile, file: *mut c_char, full_path: *mut *mut c_char, flags: GKeyFileFlags, error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_load_from_dirs(key_file: *mut GKeyFile, file: *mut c_char, search_dirs: *mut *mut c_char, full_path: *mut *mut c_char, flags: GKeyFileFlags, error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_load_from_file(key_file: *mut GKeyFile, file: *mut c_char, flags: GKeyFileFlags, error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_ref(key_file: *mut GKeyFile) -> *mut GKeyFile;
    pub fn g_key_file_remove_comment(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_remove_group(key_file: *mut GKeyFile, group_name: *const c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_remove_key(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, error: *mut *mut GError) -> gboolean;
    #[cfg(any(feature = "v2_40", feature = "dox"))]
    pub fn g_key_file_save_to_file(key_file: *mut GKeyFile, filename: *const c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_set_boolean(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, value: gboolean);
    pub fn g_key_file_set_boolean_list(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, list: gboolean, length: size_t);
    pub fn g_key_file_set_comment(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, comment: *const c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_set_double(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, value: c_double);
    pub fn g_key_file_set_double_list(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, list: c_double, length: size_t);
    pub fn g_key_file_set_int64(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, value: i64);
    pub fn g_key_file_set_integer(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, value: c_int);
    pub fn g_key_file_set_integer_list(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, list: c_int, length: size_t);
    pub fn g_key_file_set_list_separator(key_file: *mut GKeyFile, separator: c_char);
    pub fn g_key_file_set_locale_string(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, locale: *const c_char, string: *const c_char);
    pub fn g_key_file_set_locale_string_list(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, locale: *const c_char, list: *mut c_char, length: size_t);
    pub fn g_key_file_set_string(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, string: *const c_char);
    pub fn g_key_file_set_string_list(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, list: *mut c_char, length: size_t);
    pub fn g_key_file_set_uint64(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, value: u64);
    pub fn g_key_file_set_value(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, value: *const c_char);
    pub fn g_key_file_to_data(key_file: *mut GKeyFile, length: *mut size_t, error: *mut *mut GError) -> *mut c_char;
    pub fn g_key_file_unref(key_file: *mut GKeyFile);
    pub fn g_key_file_error_quark() -> GQuark;

    //=========================================================================
    // GList
    //=========================================================================
    pub fn g_list_alloc() -> *mut GList;
    pub fn g_list_append(list: *mut GList, data: gpointer) -> *mut GList;
    pub fn g_list_concat(list1: *mut GList, list2: *mut GList) -> *mut GList;
    pub fn g_list_copy(list: *mut GList) -> *mut GList;
    #[cfg(any(feature = "v2_34", feature = "dox"))]
    pub fn g_list_copy_deep(list: *mut GList, func: GCopyFunc, user_data: gpointer) -> *mut GList;
    pub fn g_list_delete_link(list: *mut GList, link_: *mut GList) -> *mut GList;
    pub fn g_list_find(list: *mut GList, data: gconstpointer) -> *mut GList;
    pub fn g_list_find_custom(list: *mut GList, data: gconstpointer, func: GCompareFunc) -> *mut GList;
    pub fn g_list_first(list: *mut GList) -> *mut GList;
    pub fn g_list_foreach(list: *mut GList, func: GFunc, user_data: gpointer);
    pub fn g_list_free(list: *mut GList);
    pub fn g_list_free_1(list: *mut GList);
    pub fn g_list_free_full(list: *mut GList, free_func: GDestroyNotify);
    pub fn g_list_index(list: *mut GList, data: gconstpointer) -> c_int;
    pub fn g_list_insert(list: *mut GList, data: gpointer, position: c_int) -> *mut GList;
    pub fn g_list_insert_before(list: *mut GList, sibling: *mut GList, data: gpointer) -> *mut GList;
    pub fn g_list_insert_sorted(list: *mut GList, data: gpointer, func: GCompareFunc) -> *mut GList;
    pub fn g_list_insert_sorted_with_data(list: *mut GList, data: gpointer, func: GCompareDataFunc, user_data: gpointer) -> *mut GList;
    pub fn g_list_last(list: *mut GList) -> *mut GList;
    pub fn g_list_length(list: *mut GList) -> c_uint;
    pub fn g_list_nth(list: *mut GList, n: c_uint) -> *mut GList;
    pub fn g_list_nth_data(list: *mut GList, n: c_uint) -> gpointer;
    pub fn g_list_nth_prev(list: *mut GList, n: c_uint) -> *mut GList;
    pub fn g_list_position(list: *mut GList, llink: *mut GList) -> c_int;
    pub fn g_list_prepend(list: *mut GList, data: gpointer) -> *mut GList;
    pub fn g_list_remove(list: *mut GList, data: gconstpointer) -> *mut GList;
    pub fn g_list_remove_all(list: *mut GList, data: gconstpointer) -> *mut GList;
    pub fn g_list_remove_link(list: *mut GList, llink: *mut GList) -> *mut GList;
    pub fn g_list_reverse(list: *mut GList) -> *mut GList;
    pub fn g_list_sort(list: *mut GList, compare_func: GCompareFunc) -> *mut GList;
    pub fn g_list_sort_with_data(list: *mut GList, compare_func: GCompareDataFunc, user_data: gpointer) -> *mut GList;

    //=========================================================================
    // GMainContext
    //=========================================================================
    pub fn g_main_context_get_type() -> GType;
    pub fn g_main_context_new() -> *mut GMainContext;
    pub fn g_main_context_acquire(context: *mut GMainContext) -> gboolean;
    pub fn g_main_context_add_poll(context: *mut GMainContext, fd: *mut GPollFD, priority: c_int);
    pub fn g_main_context_check(context: *mut GMainContext, max_priority: c_int, fds: *mut GPollFD, n_fds: c_int) -> gboolean;
    pub fn g_main_context_dispatch(context: *mut GMainContext);
    pub fn g_main_context_find_source_by_funcs_user_data(context: *mut GMainContext, funcs: *mut GSourceFuncs, user_data: gpointer) -> *mut GSource;
    pub fn g_main_context_find_source_by_id(context: *mut GMainContext, source_id: c_uint) -> *mut GSource;
    pub fn g_main_context_find_source_by_user_data(context: *mut GMainContext, user_data: gpointer) -> *mut GSource;
    pub fn g_main_context_get_poll_func(context: *mut GMainContext) -> GPollFunc;
    pub fn g_main_context_invoke(context: *mut GMainContext, function: GSourceFunc, data: gpointer);
    pub fn g_main_context_invoke_full(context: *mut GMainContext, priority: c_int, function: GSourceFunc, data: gpointer, notify: GDestroyNotify);
    pub fn g_main_context_is_owner(context: *mut GMainContext) -> gboolean;
    pub fn g_main_context_iteration(context: *mut GMainContext, may_block: gboolean) -> gboolean;
    pub fn g_main_context_pending(context: *mut GMainContext) -> gboolean;
    pub fn g_main_context_pop_thread_default(context: *mut GMainContext);
    pub fn g_main_context_prepare(context: *mut GMainContext, priority: *mut c_int) -> gboolean;
    pub fn g_main_context_push_thread_default(context: *mut GMainContext);
    pub fn g_main_context_query(context: *mut GMainContext, max_priority: c_int, timeout_: *mut c_int, fds: *mut GPollFD, n_fds: c_int) -> c_int;
    pub fn g_main_context_ref(context: *mut GMainContext) -> *mut GMainContext;
    pub fn g_main_context_release(context: *mut GMainContext);
    pub fn g_main_context_remove_poll(context: *mut GMainContext, fd: *mut GPollFD);
    pub fn g_main_context_set_poll_func(context: *mut GMainContext, func: GPollFunc);
    pub fn g_main_context_unref(context: *mut GMainContext);
    pub fn g_main_context_wait(context: *mut GMainContext, cond: *mut GCond, mutex: *mut GMutex) -> gboolean;
    pub fn g_main_context_wakeup(context: *mut GMainContext);
    pub fn g_main_context_default() -> *mut GMainContext;
    pub fn g_main_context_get_thread_default() -> *mut GMainContext;
    pub fn g_main_context_ref_thread_default() -> *mut GMainContext;

    //=========================================================================
    // GMainLoop
    //=========================================================================
    pub fn g_main_loop_get_type() -> GType;
    pub fn g_main_loop_new(context: *mut GMainContext, is_running: gboolean) -> *mut GMainLoop;
    pub fn g_main_loop_get_context(loop_: *mut GMainLoop) -> *mut GMainContext;
    pub fn g_main_loop_is_running(loop_: *mut GMainLoop) -> gboolean;
    pub fn g_main_loop_quit(loop_: *mut GMainLoop);
    pub fn g_main_loop_ref(loop_: *mut GMainLoop) -> *mut GMainLoop;
    pub fn g_main_loop_run(loop_: *mut GMainLoop);
    pub fn g_main_loop_unref(loop_: *mut GMainLoop);

    //=========================================================================
    // GMappedFile
    //=========================================================================
    pub fn g_mapped_file_get_type() -> GType;
    pub fn g_mapped_file_new(filename: *mut c_char, writable: gboolean, error: *mut *mut GError) -> *mut GMappedFile;
    pub fn g_mapped_file_new_from_fd(fd: c_int, writable: gboolean, error: *mut *mut GError) -> *mut GMappedFile;
    pub fn g_mapped_file_free(file: *mut GMappedFile);
    #[cfg(any(feature = "v2_34", feature = "dox"))]
    pub fn g_mapped_file_get_bytes(file: *mut GMappedFile) -> *mut GBytes;
    pub fn g_mapped_file_get_contents(file: *mut GMappedFile) -> *mut c_char;
    pub fn g_mapped_file_get_length(file: *mut GMappedFile) -> size_t;
    pub fn g_mapped_file_ref(file: *mut GMappedFile) -> *mut GMappedFile;
    pub fn g_mapped_file_unref(file: *mut GMappedFile);

    //=========================================================================
    // GMarkupParseContext
    //=========================================================================
    pub fn g_markup_parse_context_get_type() -> GType;
    pub fn g_markup_parse_context_new(parser: *const GMarkupParser, flags: GMarkupParseFlags, user_data: gpointer, user_data_dnotify: GDestroyNotify) -> *mut GMarkupParseContext;
    pub fn g_markup_parse_context_end_parse(context: *mut GMarkupParseContext, error: *mut *mut GError) -> gboolean;
    pub fn g_markup_parse_context_free(context: *mut GMarkupParseContext);
    pub fn g_markup_parse_context_get_element(context: *mut GMarkupParseContext) -> *const c_char;
    pub fn g_markup_parse_context_get_element_stack(context: *mut GMarkupParseContext) -> *const GSList;
    pub fn g_markup_parse_context_get_position(context: *mut GMarkupParseContext, line_number: *mut c_int, char_number: *mut c_int);
    pub fn g_markup_parse_context_get_user_data(context: *mut GMarkupParseContext) -> gpointer;
    pub fn g_markup_parse_context_parse(context: *mut GMarkupParseContext, text: *const c_char, text_len: ssize_t, error: *mut *mut GError) -> gboolean;
    pub fn g_markup_parse_context_pop(context: *mut GMarkupParseContext) -> gpointer;
    pub fn g_markup_parse_context_push(context: *mut GMarkupParseContext, parser: *const GMarkupParser, user_data: gpointer);
    #[cfg(any(feature = "v2_36", feature = "dox"))]
    pub fn g_markup_parse_context_ref(context: *mut GMarkupParseContext) -> *mut GMarkupParseContext;
    #[cfg(any(feature = "v2_36", feature = "dox"))]
    pub fn g_markup_parse_context_unref(context: *mut GMarkupParseContext);

    //=========================================================================
    // GMatchInfo
    //=========================================================================
    pub fn g_match_info_get_type() -> GType;
    pub fn g_match_info_expand_references(match_info: *const GMatchInfo, string_to_expand: *const c_char, error: *mut *mut GError) -> *mut c_char;
    pub fn g_match_info_fetch(match_info: *const GMatchInfo, match_num: c_int) -> *mut c_char;
    pub fn g_match_info_fetch_all(match_info: *const GMatchInfo) -> *mut *mut c_char;
    pub fn g_match_info_fetch_named(match_info: *const GMatchInfo, name: *const c_char) -> *mut c_char;
    pub fn g_match_info_fetch_named_pos(match_info: *const GMatchInfo, name: *const c_char, start_pos: *mut c_int, end_pos: *mut c_int) -> gboolean;
    pub fn g_match_info_fetch_pos(match_info: *const GMatchInfo, match_num: c_int, start_pos: *mut c_int, end_pos: *mut c_int) -> gboolean;
    pub fn g_match_info_free(match_info: *mut GMatchInfo);
    pub fn g_match_info_get_match_count(match_info: *const GMatchInfo) -> c_int;
    pub fn g_match_info_get_regex(match_info: *const GMatchInfo) -> *mut GRegex;
    pub fn g_match_info_get_string(match_info: *const GMatchInfo) -> *const c_char;
    pub fn g_match_info_is_partial_match(match_info: *const GMatchInfo) -> gboolean;
    pub fn g_match_info_matches(match_info: *const GMatchInfo) -> gboolean;
    pub fn g_match_info_next(match_info: *mut GMatchInfo, error: *mut *mut GError) -> gboolean;
    pub fn g_match_info_ref(match_info: *mut GMatchInfo) -> *mut GMatchInfo;
    pub fn g_match_info_unref(match_info: *mut GMatchInfo);

    //=========================================================================
    // GNode
    //=========================================================================
    pub fn g_node_child_index(node: *mut GNode, data: gpointer) -> c_int;
    pub fn g_node_child_position(node: *mut GNode, child: *mut GNode) -> c_int;
    pub fn g_node_children_foreach(node: *mut GNode, flags: GTraverseFlags, func: GNodeForeachFunc, data: gpointer);
    pub fn g_node_copy(node: *mut GNode) -> *mut GNode;
    pub fn g_node_copy_deep(node: *mut GNode, copy_func: GCopyFunc, data: gpointer) -> *mut GNode;
    pub fn g_node_depth(node: *mut GNode) -> c_uint;
    pub fn g_node_destroy(root: *mut GNode);
    pub fn g_node_find(root: *mut GNode, order: GTraverseType, flags: GTraverseFlags, data: gpointer) -> *mut GNode;
    pub fn g_node_find_child(node: *mut GNode, flags: GTraverseFlags, data: gpointer) -> *mut GNode;
    pub fn g_node_first_sibling(node: *mut GNode) -> *mut GNode;
    pub fn g_node_get_root(node: *mut GNode) -> *mut GNode;
    pub fn g_node_insert(parent: *mut GNode, position: c_int, node: *mut GNode) -> *mut GNode;
    pub fn g_node_insert_after(parent: *mut GNode, sibling: *mut GNode, node: *mut GNode) -> *mut GNode;
    pub fn g_node_insert_before(parent: *mut GNode, sibling: *mut GNode, node: *mut GNode) -> *mut GNode;
    pub fn g_node_is_ancestor(node: *mut GNode, descendant: *mut GNode) -> gboolean;
    pub fn g_node_last_child(node: *mut GNode) -> *mut GNode;
    pub fn g_node_last_sibling(node: *mut GNode) -> *mut GNode;
    pub fn g_node_max_height(root: *mut GNode) -> c_uint;
    pub fn g_node_n_children(node: *mut GNode) -> c_uint;
    pub fn g_node_n_nodes(root: *mut GNode, flags: GTraverseFlags) -> c_uint;
    pub fn g_node_nth_child(node: *mut GNode, n: c_uint) -> *mut GNode;
    pub fn g_node_prepend(parent: *mut GNode, node: *mut GNode) -> *mut GNode;
    pub fn g_node_reverse_children(node: *mut GNode);
    pub fn g_node_traverse(root: *mut GNode, order: GTraverseType, flags: GTraverseFlags, max_depth: c_int, func: GNodeTraverseFunc, data: gpointer);
    pub fn g_node_unlink(node: *mut GNode);
    pub fn g_node_new(data: gpointer) -> *mut GNode;

    //=========================================================================
    // GOnce
    //=========================================================================
    pub fn g_once_impl(once: *mut GOnce, func: GThreadFunc, arg: gpointer) -> gpointer;
    pub fn g_once_init_enter(location: *mut c_void) -> gboolean;
    pub fn g_once_init_leave(location: *mut c_void, result: size_t);

    //=========================================================================
    // GOptionContext
    //=========================================================================
    pub fn g_option_context_add_group(context: *mut GOptionContext, group: *mut GOptionGroup);
    pub fn g_option_context_add_main_entries(context: *mut GOptionContext, entries: *const GOptionEntry, translation_domain: *const c_char);
    pub fn g_option_context_free(context: *mut GOptionContext);
    pub fn g_option_context_get_description(context: *mut GOptionContext) -> *const c_char;
    pub fn g_option_context_get_help(context: *mut GOptionContext, main_help: gboolean, group: *mut GOptionGroup) -> *mut c_char;
    pub fn g_option_context_get_help_enabled(context: *mut GOptionContext) -> gboolean;
    pub fn g_option_context_get_ignore_unknown_options(context: *mut GOptionContext) -> gboolean;
    pub fn g_option_context_get_main_group(context: *mut GOptionContext) -> *mut GOptionGroup;
    #[cfg(any(feature = "v2_44", feature = "dox"))]
    pub fn g_option_context_get_strict_posix(context: *mut GOptionContext) -> gboolean;
    pub fn g_option_context_get_summary(context: *mut GOptionContext) -> *const c_char;
    pub fn g_option_context_parse(context: *mut GOptionContext, argc: *mut c_int, argv: *mut *mut *mut c_char, error: *mut *mut GError) -> gboolean;
    #[cfg(any(feature = "v2_40", feature = "dox"))]
    pub fn g_option_context_parse_strv(context: *mut GOptionContext, arguments: *mut *mut *mut c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_option_context_set_description(context: *mut GOptionContext, description: *const c_char);
    pub fn g_option_context_set_help_enabled(context: *mut GOptionContext, help_enabled: gboolean);
    pub fn g_option_context_set_ignore_unknown_options(context: *mut GOptionContext, ignore_unknown: gboolean);
    pub fn g_option_context_set_main_group(context: *mut GOptionContext, group: *mut GOptionGroup);
    #[cfg(any(feature = "v2_44", feature = "dox"))]
    pub fn g_option_context_set_strict_posix(context: *mut GOptionContext, strict_posix: gboolean);
    pub fn g_option_context_set_summary(context: *mut GOptionContext, summary: *const c_char);
    pub fn g_option_context_set_translate_func(context: *mut GOptionContext, func: GTranslateFunc, data: gpointer, destroy_notify: GDestroyNotify);
    pub fn g_option_context_set_translation_domain(context: *mut GOptionContext, domain: *const c_char);
    pub fn g_option_context_new(parameter_string: *const c_char) -> *mut GOptionContext;

    //=========================================================================
    // GOptionGroup
    //=========================================================================
    pub fn g_option_group_get_type() -> GType;
    pub fn g_option_group_new(name: *const c_char, description: *const c_char, help_description: *const c_char, user_data: gpointer, destroy: GDestroyNotify) -> *mut GOptionGroup;
    pub fn g_option_group_add_entries(group: *mut GOptionGroup, entries: *const GOptionEntry);
    pub fn g_option_group_free(group: *mut GOptionGroup);
    #[cfg(any(feature = "v2_44", feature = "dox"))]
    pub fn g_option_group_ref(group: *mut GOptionGroup) -> *mut GOptionGroup;
    pub fn g_option_group_set_error_hook(group: *mut GOptionGroup, error_func: GOptionErrorFunc);
    pub fn g_option_group_set_parse_hooks(group: *mut GOptionGroup, pre_parse_func: GOptionParseFunc, post_parse_func: GOptionParseFunc);
    pub fn g_option_group_set_translate_func(group: *mut GOptionGroup, func: GTranslateFunc, data: gpointer, destroy_notify: GDestroyNotify);
    pub fn g_option_group_set_translation_domain(group: *mut GOptionGroup, domain: *const c_char);
    #[cfg(any(feature = "v2_44", feature = "dox"))]
    pub fn g_option_group_unref(group: *mut GOptionGroup);

    //=========================================================================
    // GPatternSpec
    //=========================================================================
    pub fn g_pattern_spec_equal(pspec1: *mut GPatternSpec, pspec2: *mut GPatternSpec) -> gboolean;
    pub fn g_pattern_spec_free(pspec: *mut GPatternSpec);
    pub fn g_pattern_spec_new(pattern: *const c_char) -> *mut GPatternSpec;

    //=========================================================================
    // GPollFD
    //=========================================================================
    pub fn g_pollfd_get_type() -> GType;

    //=========================================================================
    // GPrivate
    //=========================================================================
    pub fn g_private_get(key: *mut GPrivate) -> gpointer;
    pub fn g_private_replace(key: *mut GPrivate, value: gpointer);
    pub fn g_private_set(key: *mut GPrivate, value: gpointer);

    //=========================================================================
    // GPtrArray
    //=========================================================================
    pub fn g_ptr_array_get_type() -> GType;
    pub fn g_ptr_array_add(array: *mut GPtrArray, data: gpointer);
    #[cfg(any(feature = "v2_54", feature = "dox"))]
    pub fn g_ptr_array_find(haystack: *mut GPtrArray, needle: gconstpointer, index_: *mut c_uint) -> gboolean;
    #[cfg(any(feature = "v2_54", feature = "dox"))]
    pub fn g_ptr_array_find_with_equal_func(haystack: *mut GPtrArray, needle: gconstpointer, equal_func: GEqualFunc, index_: *mut c_uint) -> gboolean;
    pub fn g_ptr_array_foreach(array: *mut GPtrArray, func: GFunc, user_data: gpointer);
    pub fn g_ptr_array_free(array: *mut GPtrArray, free_seg: gboolean) -> *mut gpointer;
    #[cfg(any(feature = "v2_40", feature = "dox"))]
    pub fn g_ptr_array_insert(array: *mut GPtrArray, index_: c_int, data: gpointer);
    pub fn g_ptr_array_new() -> *mut GPtrArray;
    pub fn g_ptr_array_new_full(reserved_size: c_uint, element_free_func: GDestroyNotify) -> *mut GPtrArray;
    pub fn g_ptr_array_new_with_free_func(element_free_func: GDestroyNotify) -> *mut GPtrArray;
    pub fn g_ptr_array_ref(array: *mut GPtrArray) -> *mut GPtrArray;
    pub fn g_ptr_array_remove(array: *mut GPtrArray, data: gpointer) -> gboolean;
    pub fn g_ptr_array_remove_fast(array: *mut GPtrArray, data: gpointer) -> gboolean;
    pub fn g_ptr_array_remove_index(array: *mut GPtrArray, index_: c_uint) -> gpointer;
    pub fn g_ptr_array_remove_index_fast(array: *mut GPtrArray, index_: c_uint) -> gpointer;
    pub fn g_ptr_array_remove_range(array: *mut GPtrArray, index_: c_uint, length: c_uint) -> *mut GPtrArray;
    pub fn g_ptr_array_set_free_func(array: *mut GPtrArray, element_free_func: GDestroyNotify);
    pub fn g_ptr_array_set_size(array: *mut GPtrArray, length: c_int);
    pub fn g_ptr_array_sized_new(reserved_size: c_uint) -> *mut GPtrArray;
    pub fn g_ptr_array_sort(array: *mut GPtrArray, compare_func: GCompareFunc);
    pub fn g_ptr_array_sort_with_data(array: *mut GPtrArray, compare_func: GCompareDataFunc, user_data: gpointer);
    pub fn g_ptr_array_unref(array: *mut GPtrArray);

    //=========================================================================
    // GQueue
    //=========================================================================
    pub fn g_queue_clear(queue: *mut GQueue);
    pub fn g_queue_copy(queue: *mut GQueue) -> *mut GQueue;
    pub fn g_queue_delete_link(queue: *mut GQueue, link_: *mut GList);
    pub fn g_queue_find(queue: *mut GQueue, data: gconstpointer) -> *mut GList;
    pub fn g_queue_find_custom(queue: *mut GQueue, data: gconstpointer, func: GCompareFunc) -> *mut GList;
    pub fn g_queue_foreach(queue: *mut GQueue, func: GFunc, user_data: gpointer);
    pub fn g_queue_free(queue: *mut GQueue);
    pub fn g_queue_free_full(queue: *mut GQueue, free_func: GDestroyNotify);
    pub fn g_queue_get_length(queue: *mut GQueue) -> c_uint;
    pub fn g_queue_index(queue: *mut GQueue, data: gconstpointer) -> c_int;
    pub fn g_queue_init(queue: *mut GQueue);
    pub fn g_queue_insert_after(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
    pub fn g_queue_insert_before(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
    pub fn g_queue_insert_sorted(queue: *mut GQueue, data: gpointer, func: GCompareDataFunc, user_data: gpointer);
    pub fn g_queue_is_empty(queue: *mut GQueue) -> gboolean;
    pub fn g_queue_link_index(queue: *mut GQueue, link_: *mut GList) -> c_int;
    pub fn g_queue_peek_head(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_peek_head_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_peek_nth(queue: *mut GQueue, n: c_uint) -> gpointer;
    pub fn g_queue_peek_nth_link(queue: *mut GQueue, n: c_uint) -> *mut GList;
    pub fn g_queue_peek_tail(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_peek_tail_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_pop_head(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_pop_head_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_pop_nth(queue: *mut GQueue, n: c_uint) -> gpointer;
    pub fn g_queue_pop_nth_link(queue: *mut GQueue, n: c_uint) -> *mut GList;
    pub fn g_queue_pop_tail(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_pop_tail_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_push_head(queue: *mut GQueue, data: gpointer);
    pub fn g_queue_push_head_link(queue: *mut GQueue, link_: *mut GList);
    pub fn g_queue_push_nth(queue: *mut GQueue, data: gpointer, n: c_int);
    pub fn g_queue_push_nth_link(queue: *mut GQueue, n: c_int, link_: *mut GList);
    pub fn g_queue_push_tail(queue: *mut GQueue, data: gpointer);
    pub fn g_queue_push_tail_link(queue: *mut GQueue, link_: *mut GList);
    pub fn g_queue_remove(queue: *mut GQueue, data: gconstpointer) -> gboolean;
    pub fn g_queue_remove_all(queue: *mut GQueue, data: gconstpointer) -> c_uint;
    pub fn g_queue_reverse(queue: *mut GQueue);
    pub fn g_queue_sort(queue: *mut GQueue, compare_func: GCompareDataFunc, user_data: gpointer);
    pub fn g_queue_unlink(queue: *mut GQueue, link_: *mut GList);
    pub fn g_queue_new() -> *mut GQueue;

    //=========================================================================
    // GRWLock
    //=========================================================================
    pub fn g_rw_lock_clear(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_init(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_reader_lock(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_reader_trylock(rw_lock: *mut GRWLock) -> gboolean;
    pub fn g_rw_lock_reader_unlock(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_writer_lock(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_writer_trylock(rw_lock: *mut GRWLock) -> gboolean;
    pub fn g_rw_lock_writer_unlock(rw_lock: *mut GRWLock);

    //=========================================================================
    // GRand
    //=========================================================================
    pub fn g_rand_copy(rand_: *mut GRand) -> *mut GRand;
    pub fn g_rand_double(rand_: *mut GRand) -> c_double;
    pub fn g_rand_double_range(rand_: *mut GRand, begin: c_double, end: c_double) -> c_double;
    pub fn g_rand_free(rand_: *mut GRand);
    pub fn g_rand_int(rand_: *mut GRand) -> u32;
    pub fn g_rand_int_range(rand_: *mut GRand, begin: i32, end: i32) -> i32;
    pub fn g_rand_set_seed(rand_: *mut GRand, seed: u32);
    pub fn g_rand_set_seed_array(rand_: *mut GRand, seed: *const u32, seed_length: c_uint);
    pub fn g_rand_new() -> *mut GRand;
    pub fn g_rand_new_with_seed(seed: u32) -> *mut GRand;
    pub fn g_rand_new_with_seed_array(seed: *const u32, seed_length: c_uint) -> *mut GRand;

    //=========================================================================
    // GRecMutex
    //=========================================================================
    pub fn g_rec_mutex_clear(rec_mutex: *mut GRecMutex);
    pub fn g_rec_mutex_init(rec_mutex: *mut GRecMutex);
    pub fn g_rec_mutex_lock(rec_mutex: *mut GRecMutex);
    pub fn g_rec_mutex_trylock(rec_mutex: *mut GRecMutex) -> gboolean;
    pub fn g_rec_mutex_unlock(rec_mutex: *mut GRecMutex);

    //=========================================================================
    // GRegex
    //=========================================================================
    pub fn g_regex_get_type() -> GType;
    pub fn g_regex_new(pattern: *const c_char, compile_options: GRegexCompileFlags, match_options: GRegexMatchFlags, error: *mut *mut GError) -> *mut GRegex;
    pub fn g_regex_get_capture_count(regex: *const GRegex) -> c_int;
    pub fn g_regex_get_compile_flags(regex: *const GRegex) -> GRegexCompileFlags;
    #[cfg(any(feature = "v2_34", feature = "dox"))]
    pub fn g_regex_get_has_cr_or_lf(regex: *const GRegex) -> gboolean;
    pub fn g_regex_get_match_flags(regex: *const GRegex) -> GRegexMatchFlags;
    pub fn g_regex_get_max_backref(regex: *const GRegex) -> c_int;
    #[cfg(any(feature = "v2_38", feature = "dox"))]
    pub fn g_regex_get_max_lookbehind(regex: *const GRegex) -> c_int;
    pub fn g_regex_get_pattern(regex: *const GRegex) -> *const c_char;
    pub fn g_regex_get_string_number(regex: *const GRegex, name: *const c_char) -> c_int;
    pub fn g_regex_match(regex: *const GRegex, string: *const c_char, match_options: GRegexMatchFlags, match_info: *mut *mut GMatchInfo) -> gboolean;
    pub fn g_regex_match_all(regex: *const GRegex, string: *const c_char, match_options: GRegexMatchFlags, match_info: *mut *mut GMatchInfo) -> gboolean;
    pub fn g_regex_match_all_full(regex: *const GRegex, string: *mut c_char, string_len: ssize_t, start_position: c_int, match_options: GRegexMatchFlags, match_info: *mut *mut GMatchInfo, error: *mut *mut GError) -> gboolean;
    pub fn g_regex_match_full(regex: *const GRegex, string: *mut c_char, string_len: ssize_t, start_position: c_int, match_options: GRegexMatchFlags, match_info: *mut *mut GMatchInfo, error: *mut *mut GError) -> gboolean;
    pub fn g_regex_ref(regex: *mut GRegex) -> *mut GRegex;
    pub fn g_regex_replace(regex: *const GRegex, string: *mut c_char, string_len: ssize_t, start_position: c_int, replacement: *const c_char, match_options: GRegexMatchFlags, error: *mut *mut GError) -> *mut c_char;
    pub fn g_regex_replace_eval(regex: *const GRegex, string: *mut c_char, string_len: ssize_t, start_position: c_int, match_options: GRegexMatchFlags, eval: GRegexEvalCallback, user_data: gpointer, error: *mut *mut GError) -> *mut c_char;
    pub fn g_regex_replace_literal(regex: *const GRegex, string: *mut c_char, string_len: ssize_t, start_position: c_int, replacement: *const c_char, match_options: GRegexMatchFlags, error: *mut *mut GError) -> *mut c_char;
    pub fn g_regex_split(regex: *const GRegex, string: *const c_char, match_options: GRegexMatchFlags) -> *mut *mut c_char;
    pub fn g_regex_split_full(regex: *const GRegex, string: *mut c_char, string_len: ssize_t, start_position: c_int, match_options: GRegexMatchFlags, max_tokens: c_int, error: *mut *mut GError) -> *mut *mut c_char;
    pub fn g_regex_unref(regex: *mut GRegex);
    pub fn g_regex_check_replacement(replacement: *const c_char, has_references: *mut gboolean, error: *mut *mut GError) -> gboolean;
    pub fn g_regex_error_quark() -> GQuark;
    pub fn g_regex_escape_nul(string: *const c_char, length: c_int) -> *mut c_char;
    pub fn g_regex_escape_string(string: *mut c_char, length: c_int) -> *mut c_char;
    pub fn g_regex_match_simple(pattern: *const c_char, string: *const c_char, compile_options: GRegexCompileFlags, match_options: GRegexMatchFlags) -> gboolean;
    pub fn g_regex_split_simple(pattern: *const c_char, string: *const c_char, compile_options: GRegexCompileFlags, match_options: GRegexMatchFlags) -> *mut *mut c_char;

    //=========================================================================
    // GSList
    //=========================================================================
    pub fn g_slist_alloc() -> *mut GSList;
    pub fn g_slist_append(list: *mut GSList, data: gpointer) -> *mut GSList;
    pub fn g_slist_concat(list1: *mut GSList, list2: *mut GSList) -> *mut GSList;
    pub fn g_slist_copy(list: *mut GSList) -> *mut GSList;
    #[cfg(any(feature = "v2_34", feature = "dox"))]
    pub fn g_slist_copy_deep(list: *mut GSList, func: GCopyFunc, user_data: gpointer) -> *mut GSList;
    pub fn g_slist_delete_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
    pub fn g_slist_find(list: *mut GSList, data: gconstpointer) -> *mut GSList;
    pub fn g_slist_find_custom(list: *mut GSList, data: gconstpointer, func: GCompareFunc) -> *mut GSList;
    pub fn g_slist_foreach(list: *mut GSList, func: GFunc, user_data: gpointer);
    pub fn g_slist_free(list: *mut GSList);
    pub fn g_slist_free_1(list: *mut GSList);
    pub fn g_slist_free_full(list: *mut GSList, free_func: GDestroyNotify);
    pub fn g_slist_index(list: *mut GSList, data: gconstpointer) -> c_int;
    pub fn g_slist_insert(list: *mut GSList, data: gpointer, position: c_int) -> *mut GSList;
    pub fn g_slist_insert_before(slist: *mut GSList, sibling: *mut GSList, data: gpointer) -> *mut GSList;
    pub fn g_slist_insert_sorted(list: *mut GSList, data: gpointer, func: GCompareFunc) -> *mut GSList;
    pub fn g_slist_insert_sorted_with_data(list: *mut GSList, data: gpointer, func: GCompareDataFunc, user_data: gpointer) -> *mut GSList;
    pub fn g_slist_last(list: *mut GSList) -> *mut GSList;
    pub fn g_slist_length(list: *mut GSList) -> c_uint;
    pub fn g_slist_nth(list: *mut GSList, n: c_uint) -> *mut GSList;
    pub fn g_slist_nth_data(list: *mut GSList, n: c_uint) -> gpointer;
    pub fn g_slist_position(list: *mut GSList, llink: *mut GSList) -> c_int;
    pub fn g_slist_prepend(list: *mut GSList, data: gpointer) -> *mut GSList;
    pub fn g_slist_remove(list: *mut GSList, data: gconstpointer) -> *mut GSList;
    pub fn g_slist_remove_all(list: *mut GSList, data: gconstpointer) -> *mut GSList;
    pub fn g_slist_remove_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
    pub fn g_slist_reverse(list: *mut GSList) -> *mut GSList;
    pub fn g_slist_sort(list: *mut GSList, compare_func: GCompareFunc) -> *mut GSList;
    pub fn g_slist_sort_with_data(list: *mut GSList, compare_func: GCompareDataFunc, user_data: gpointer) -> *mut GSList;

    //=========================================================================
    // GScanner
    //=========================================================================
    pub fn g_scanner_cur_line(scanner: *mut GScanner) -> c_uint;
    pub fn g_scanner_cur_position(scanner: *mut GScanner) -> c_uint;
    pub fn g_scanner_cur_token(scanner: *mut GScanner) -> GTokenType;
    pub fn g_scanner_cur_value(scanner: *mut GScanner) -> GTokenValue;
    pub fn g_scanner_destroy(scanner: *mut GScanner);
    pub fn g_scanner_eof(scanner: *mut GScanner) -> gboolean;
    pub fn g_scanner_error(scanner: *mut GScanner, format: *const c_char, ...);
    pub fn g_scanner_get_next_token(scanner: *mut GScanner) -> GTokenType;
    pub fn g_scanner_input_file(scanner: *mut GScanner, input_fd: c_int);
    pub fn g_scanner_input_text(scanner: *mut GScanner, text: *const c_char, text_len: c_uint);
    pub fn g_scanner_lookup_symbol(scanner: *mut GScanner, symbol: *const c_char) -> gpointer;
    pub fn g_scanner_peek_next_token(scanner: *mut GScanner) -> GTokenType;
    pub fn g_scanner_scope_add_symbol(scanner: *mut GScanner, scope_id: c_uint, symbol: *const c_char, value: gpointer);
    pub fn g_scanner_scope_foreach_symbol(scanner: *mut GScanner, scope_id: c_uint, func: GHFunc, user_data: gpointer);
    pub fn g_scanner_scope_lookup_symbol(scanner: *mut GScanner, scope_id: c_uint, symbol: *const c_char) -> gpointer;
    pub fn g_scanner_scope_remove_symbol(scanner: *mut GScanner, scope_id: c_uint, symbol: *const c_char);
    pub fn g_scanner_set_scope(scanner: *mut GScanner, scope_id: c_uint) -> c_uint;
    pub fn g_scanner_sync_file_offset(scanner: *mut GScanner);
    pub fn g_scanner_unexp_token(scanner: *mut GScanner, expected_token: GTokenType, identifier_spec: *const c_char, symbol_spec: *const c_char, symbol_name: *const c_char, message: *const c_char, is_error: c_int);
    pub fn g_scanner_warn(scanner: *mut GScanner, format: *const c_char, ...);
    pub fn g_scanner_new(config_templ: *const GScannerConfig) -> *mut GScanner;

    //=========================================================================
    // GSequence
    //=========================================================================
    pub fn g_sequence_append(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_foreach(seq: *mut GSequence, func: GFunc, user_data: gpointer);
    pub fn g_sequence_free(seq: *mut GSequence);
    pub fn g_sequence_get_begin_iter(seq: *mut GSequence) -> *mut GSequenceIter;
    pub fn g_sequence_get_end_iter(seq: *mut GSequence) -> *mut GSequenceIter;
    pub fn g_sequence_get_iter_at_pos(seq: *mut GSequence, pos: c_int) -> *mut GSequenceIter;
    pub fn g_sequence_get_length(seq: *mut GSequence) -> c_int;
    pub fn g_sequence_insert_sorted(seq: *mut GSequence, data: gpointer, cmp_func: GCompareDataFunc, cmp_data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_insert_sorted_iter(seq: *mut GSequence, data: gpointer, iter_cmp: GSequenceIterCompareFunc, cmp_data: gpointer) -> *mut GSequenceIter;
    #[cfg(any(feature = "v2_48", feature = "dox"))]
    pub fn g_sequence_is_empty(seq: *mut GSequence) -> gboolean;
    pub fn g_sequence_lookup(seq: *mut GSequence, data: gpointer, cmp_func: GCompareDataFunc, cmp_data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_lookup_iter(seq: *mut GSequence, data: gpointer, iter_cmp: GSequenceIterCompareFunc, cmp_data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_prepend(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_search(seq: *mut GSequence, data: gpointer, cmp_func: GCompareDataFunc, cmp_data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_search_iter(seq: *mut GSequence, data: gpointer, iter_cmp: GSequenceIterCompareFunc, cmp_data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_sort(seq: *mut GSequence, cmp_func: GCompareDataFunc, cmp_data: gpointer);
    pub fn g_sequence_sort_iter(seq: *mut GSequence, cmp_func: GSequenceIterCompareFunc, cmp_data: gpointer);
    pub fn g_sequence_foreach_range(begin: *mut GSequenceIter, end: *mut GSequenceIter, func: GFunc, user_data: gpointer);
    pub fn g_sequence_get(iter: *mut GSequenceIter) -> gpointer;
    pub fn g_sequence_insert_before(iter: *mut GSequenceIter, data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_move(src: *mut GSequenceIter, dest: *mut GSequenceIter);
    pub fn g_sequence_move_range(dest: *mut GSequenceIter, begin: *mut GSequenceIter, end: *mut GSequenceIter);
    pub fn g_sequence_new(data_destroy: GDestroyNotify) -> *mut GSequence;
    pub fn g_sequence_range_get_midpoint(begin: *mut GSequenceIter, end: *mut GSequenceIter) -> *mut GSequenceIter;
    pub fn g_sequence_remove(iter: *mut GSequenceIter);
    pub fn g_sequence_remove_range(begin: *mut GSequenceIter, end: *mut GSequenceIter);
    pub fn g_sequence_set(iter: *mut GSequenceIter, data: gpointer);
    pub fn g_sequence_sort_changed(iter: *mut GSequenceIter, cmp_func: GCompareDataFunc, cmp_data: gpointer);
    pub fn g_sequence_sort_changed_iter(iter: *mut GSequenceIter, iter_cmp: GSequenceIterCompareFunc, cmp_data: gpointer);
    pub fn g_sequence_swap(a: *mut GSequenceIter, b: *mut GSequenceIter);

    //=========================================================================
    // GSequenceIter
    //=========================================================================
    pub fn g_sequence_iter_compare(a: *mut GSequenceIter, b: *mut GSequenceIter) -> c_int;
    pub fn g_sequence_iter_get_position(iter: *mut GSequenceIter) -> c_int;
    pub fn g_sequence_iter_get_sequence(iter: *mut GSequenceIter) -> *mut GSequence;
    pub fn g_sequence_iter_is_begin(iter: *mut GSequenceIter) -> gboolean;
    pub fn g_sequence_iter_is_end(iter: *mut GSequenceIter) -> gboolean;
    pub fn g_sequence_iter_move(iter: *mut GSequenceIter, delta: c_int) -> *mut GSequenceIter;
    pub fn g_sequence_iter_next(iter: *mut GSequenceIter) -> *mut GSequenceIter;
    pub fn g_sequence_iter_prev(iter: *mut GSequenceIter) -> *mut GSequenceIter;

    //=========================================================================
    // GSource
    //=========================================================================
    pub fn g_source_get_type() -> GType;
    pub fn g_source_new(source_funcs: *mut GSourceFuncs, struct_size: c_uint) -> *mut GSource;
    pub fn g_source_add_child_source(source: *mut GSource, child_source: *mut GSource);
    pub fn g_source_add_poll(source: *mut GSource, fd: *mut GPollFD);
    #[cfg(any(feature = "v2_36", feature = "dox"))]
    pub fn g_source_add_unix_fd(source: *mut GSource, fd: c_int, events: GIOCondition) -> gpointer;
    pub fn g_source_attach(source: *mut GSource, context: *mut GMainContext) -> c_uint;
    pub fn g_source_destroy(source: *mut GSource);
    pub fn g_source_get_can_recurse(source: *mut GSource) -> gboolean;
    pub fn g_source_get_context(source: *mut GSource) -> *mut GMainContext;
    pub fn g_source_get_current_time(source: *mut GSource, timeval: *mut GTimeVal);
    pub fn g_source_get_id(source: *mut GSource) -> c_uint;
    pub fn g_source_get_name(source: *mut GSource) -> *const c_char;
    pub fn g_source_get_priority(source: *mut GSource) -> c_int;
    pub fn g_source_get_ready_time(source: *mut GSource) -> i64;
    pub fn g_source_get_time(source: *mut GSource) -> i64;
    pub fn g_source_is_destroyed(source: *mut GSource) -> gboolean;
    #[cfg(any(feature = "v2_36", feature = "dox"))]
    pub fn g_source_modify_unix_fd(source: *mut GSource, tag: gpointer, new_events: GIOCondition);
    #[cfg(any(feature = "v2_36", feature = "dox"))]
    pub fn g_source_query_unix_fd(source: *mut GSource, tag: gpointer) -> GIOCondition;
    pub fn g_source_ref(source: *mut GSource) -> *mut GSource;
    pub fn g_source_remove_child_source(source: *mut GSource, child_source: *mut GSource);
    pub fn g_source_remove_poll(source: *mut GSource, fd: *mut GPollFD);
    #[cfg(any(feature = "v2_36", feature = "dox"))]
    pub fn g_source_remove_unix_fd(source: *mut GSource, tag: gpointer);
    pub fn g_source_set_callback(source: *mut GSource, func: GSourceFunc, data: gpointer, notify: GDestroyNotify);
    pub fn g_source_set_callback_indirect(source: *mut GSource, callback_data: gpointer, callback_funcs: *mut GSourceCallbackFuncs);
    pub fn g_source_set_can_recurse(source: *mut GSource, can_recurse: gboolean);
    pub fn g_source_set_funcs(source: *mut GSource, funcs: *mut GSourceFuncs);
    pub fn g_source_set_name(source: *mut GSource, name: *const c_char);
    pub fn g_source_set_priority(source: *mut GSource, priority: c_int);
    #[cfg(any(feature = "v2_36", feature = "dox"))]
    pub fn g_source_set_ready_time(source: *mut GSource, ready_time: i64);
    pub fn g_source_unref(source: *mut GSource);
    pub fn g_source_remove(tag: c_uint) -> gboolean;
    pub fn g_source_remove_by_funcs_user_data(funcs: *mut GSourceFuncs, user_data: gpointer) -> gboolean;
    pub fn g_source_remove_by_user_data(user_data: gpointer) -> gboolean;
    pub fn g_source_set_name_by_id(tag: c_uint, name: *const c_char);

    //=========================================================================
    // GString
    //=========================================================================
    pub fn g_gstring_get_type() -> GType;
    pub fn g_string_append(string: *mut GString, val: *const c_char) -> *mut GString;
    pub fn g_string_append_c(string: *mut GString, c: c_char) -> *mut GString;
    pub fn g_string_append_len(string: *mut GString, val: *const c_char, len: ssize_t) -> *mut GString;
    pub fn g_string_append_printf(string: *mut GString, format: *const c_char, ...);
    pub fn g_string_append_unichar(string: *mut GString, wc: u32) -> *mut GString;
    pub fn g_string_append_uri_escaped(string: *mut GString, unescaped: *const c_char, reserved_chars_allowed: *const c_char, allow_utf8: gboolean) -> *mut GString;
    //pub fn g_string_append_vprintf(string: *mut GString, format: *const c_char, args: /*Unimplemented*/va_list);
    pub fn g_string_ascii_down(string: *mut GString) -> *mut GString;
    pub fn g_string_ascii_up(string: *mut GString) -> *mut GString;
    pub fn g_string_assign(string: *mut GString, rval: *const c_char) -> *mut GString;
    pub fn g_string_down(string: *mut GString) -> *mut GString;
    pub fn g_string_equal(v: *const GString, v2: *const GString) -> gboolean;
    pub fn g_string_erase(string: *mut GString, pos: ssize_t, len: ssize_t) -> *mut GString;
    pub fn g_string_free(string: *mut GString, free_segment: gboolean) -> *mut c_char;
    #[cfg(any(feature = "v2_34", feature = "dox"))]
    pub fn g_string_free_to_bytes(string: *mut GString) -> *mut GBytes;
    pub fn g_string_hash(str: *const GString) -> c_uint;
    pub fn g_string_insert(string: *mut GString, pos: ssize_t, val: *const c_char) -> *mut GString;
    pub fn g_string_insert_c(string: *mut GString, pos: ssize_t, c: c_char) -> *mut GString;
    pub fn g_string_insert_len(string: *mut GString, pos: ssize_t, val: *const c_char, len: ssize_t) -> *mut GString;
    pub fn g_string_insert_unichar(string: *mut GString, pos: ssize_t, wc: u32) -> *mut GString;
    pub fn g_string_overwrite(string: *mut GString, pos: size_t, val: *const c_char) -> *mut GString;
    pub fn g_string_overwrite_len(string: *mut GString, pos: size_t, val: *const c_char, len: ssize_t) -> *mut GString;
    pub fn g_string_prepend(string: *mut GString, val: *const c_char) -> *mut GString;
    pub fn g_string_prepend_c(string: *mut GString, c: c_char) -> *mut GString;
    pub fn g_string_prepend_len(string: *mut GString, val: *const c_char, len: ssize_t) -> *mut GString;
    pub fn g_string_prepend_unichar(string: *mut GString, wc: u32) -> *mut GString;
    pub fn g_string_printf(string: *mut GString, format: *const c_char, ...);
    pub fn g_string_set_size(string: *mut GString, len: size_t) -> *mut GString;
    pub fn g_string_truncate(string: *mut GString, len: size_t) -> *mut GString;
    pub fn g_string_up(string: *mut GString) -> *mut GString;
    //pub fn g_string_vprintf(string: *mut GString, format: *const c_char, args: /*Unimplemented*/va_list);

    //=========================================================================
    // GStringChunk
    //=========================================================================
    pub fn g_string_chunk_clear(chunk: *mut GStringChunk);
    pub fn g_string_chunk_free(chunk: *mut GStringChunk);
    pub fn g_string_chunk_insert(chunk: *mut GStringChunk, string: *const c_char) -> *mut c_char;
    pub fn g_string_chunk_insert_const(chunk: *mut GStringChunk, string: *const c_char) -> *mut c_char;
    pub fn g_string_chunk_insert_len(chunk: *mut GStringChunk, string: *const c_char, len: ssize_t) -> *mut c_char;
    pub fn g_string_chunk_new(size: size_t) -> *mut GStringChunk;

    //=========================================================================
    // GTestLogBuffer
    //=========================================================================
    pub fn g_test_log_buffer_free(tbuffer: *mut GTestLogBuffer);
    pub fn g_test_log_buffer_pop(tbuffer: *mut GTestLogBuffer) -> *mut GTestLogMsg;
    pub fn g_test_log_buffer_push(tbuffer: *mut GTestLogBuffer, n_bytes: c_uint, bytes: *const u8);
    pub fn g_test_log_buffer_new() -> *mut GTestLogBuffer;

    //=========================================================================
    // GTestLogMsg
    //=========================================================================
    pub fn g_test_log_msg_free(tmsg: *mut GTestLogMsg);

    //=========================================================================
    // GTestSuite
    //=========================================================================
    pub fn g_test_suite_add(suite: *mut GTestSuite, test_case: *mut GTestCase);
    pub fn g_test_suite_add_suite(suite: *mut GTestSuite, nestedsuite: *mut GTestSuite);

    //=========================================================================
    // GThread
    //=========================================================================
    pub fn g_thread_get_type() -> GType;
    pub fn g_thread_new(name: *const c_char, func: GThreadFunc, data: gpointer) -> *mut GThread;
    pub fn g_thread_try_new(name: *const c_char, func: GThreadFunc, data: gpointer, error: *mut *mut GError) -> *mut GThread;
    pub fn g_thread_join(thread: *mut GThread) -> gpointer;
    pub fn g_thread_ref(thread: *mut GThread) -> *mut GThread;
    pub fn g_thread_unref(thread: *mut GThread);
    pub fn g_thread_error_quark() -> GQuark;
    pub fn g_thread_exit(retval: gpointer);
    pub fn g_thread_self() -> *mut GThread;
    pub fn g_thread_yield();

    //=========================================================================
    // GThreadPool
    //=========================================================================
    pub fn g_thread_pool_free(pool: *mut GThreadPool, immediate: gboolean, wait_: gboolean);
    pub fn g_thread_pool_get_max_threads(pool: *mut GThreadPool) -> c_int;
    pub fn g_thread_pool_get_num_threads(pool: *mut GThreadPool) -> c_uint;
    #[cfg(any(feature = "v2_46", feature = "dox"))]
    pub fn g_thread_pool_move_to_front(pool: *mut GThreadPool, data: gpointer) -> gboolean;
    pub fn g_thread_pool_push(pool: *mut GThreadPool, data: gpointer, error: *mut *mut GError) -> gboolean;
    pub fn g_thread_pool_set_max_threads(pool: *mut GThreadPool, max_threads: c_int, error: *mut *mut GError) -> gboolean;
    pub fn g_thread_pool_set_sort_function(pool: *mut GThreadPool, func: GCompareDataFunc, user_data: gpointer);
    pub fn g_thread_pool_unprocessed(pool: *mut GThreadPool) -> c_uint;
    pub fn g_thread_pool_get_max_idle_time() -> c_uint;
    pub fn g_thread_pool_get_max_unused_threads() -> c_int;
    pub fn g_thread_pool_get_num_unused_threads() -> c_uint;
    pub fn g_thread_pool_new(func: GFunc, user_data: gpointer, max_threads: c_int, exclusive: gboolean, error: *mut *mut GError) -> *mut GThreadPool;
    pub fn g_thread_pool_set_max_idle_time(interval: c_uint);
    pub fn g_thread_pool_set_max_unused_threads(max_threads: c_int);
    pub fn g_thread_pool_stop_unused_threads();

    //=========================================================================
    // GTimeVal
    //=========================================================================
    pub fn g_time_val_add(time_: *mut GTimeVal, microseconds: c_long);
    pub fn g_time_val_to_iso8601(time_: *mut GTimeVal) -> *mut c_char;
    pub fn g_time_val_from_iso8601(iso_date: *const c_char, time_: *mut GTimeVal) -> gboolean;

    //=========================================================================
    // GTimeZone
    //=========================================================================
    pub fn g_time_zone_get_type() -> GType;
    pub fn g_time_zone_new(identifier: *const c_char) -> *mut GTimeZone;
    pub fn g_time_zone_new_local() -> *mut GTimeZone;
    pub fn g_time_zone_new_utc() -> *mut GTimeZone;
    pub fn g_time_zone_adjust_time(tz: *mut GTimeZone, type_: GTimeType, time_: *mut i64) -> c_int;
    pub fn g_time_zone_find_interval(tz: *mut GTimeZone, type_: GTimeType, time_: i64) -> c_int;
    pub fn g_time_zone_get_abbreviation(tz: *mut GTimeZone, interval: c_int) -> *const c_char;
    pub fn g_time_zone_get_offset(tz: *mut GTimeZone, interval: c_int) -> i32;
    pub fn g_time_zone_is_dst(tz: *mut GTimeZone, interval: c_int) -> gboolean;
    pub fn g_time_zone_ref(tz: *mut GTimeZone) -> *mut GTimeZone;
    pub fn g_time_zone_unref(tz: *mut GTimeZone);

    //=========================================================================
    // GTimer
    //=========================================================================
    pub fn g_timer_continue(timer: *mut GTimer);
    pub fn g_timer_destroy(timer: *mut GTimer);
    pub fn g_timer_elapsed(timer: *mut GTimer, microseconds: *mut c_ulong) -> c_double;
    pub fn g_timer_reset(timer: *mut GTimer);
    pub fn g_timer_start(timer: *mut GTimer);
    pub fn g_timer_stop(timer: *mut GTimer);
    pub fn g_timer_new() -> *mut GTimer;

    //=========================================================================
    // GTrashStack
    //=========================================================================
    pub fn g_trash_stack_height(stack_p: *mut *mut GTrashStack) -> c_uint;
    pub fn g_trash_stack_peek(stack_p: *mut *mut GTrashStack) -> gpointer;
    pub fn g_trash_stack_pop(stack_p: *mut *mut GTrashStack) -> gpointer;
    pub fn g_trash_stack_push(stack_p: *mut *mut GTrashStack, data_p: gpointer);

    //=========================================================================
    // GTree
    //=========================================================================
    pub fn g_tree_destroy(tree: *mut GTree);
    pub fn g_tree_foreach(tree: *mut GTree, func: GTraverseFunc, user_data: gpointer);
    pub fn g_tree_height(tree: *mut GTree) -> c_int;
    pub fn g_tree_insert(tree: *mut GTree, key: gpointer, value: gpointer);
    pub fn g_tree_lookup(tree: *mut GTree, key: gconstpointer) -> gpointer;
    pub fn g_tree_lookup_extended(tree: *mut GTree, lookup_key: gconstpointer, orig_key: *mut gpointer, value: *mut gpointer) -> gboolean;
    pub fn g_tree_nnodes(tree: *mut GTree) -> c_int;
    pub fn g_tree_ref(tree: *mut GTree) -> *mut GTree;
    pub fn g_tree_remove(tree: *mut GTree, key: gconstpointer) -> gboolean;
    pub fn g_tree_replace(tree: *mut GTree, key: gpointer, value: gpointer);
    pub fn g_tree_search(tree: *mut GTree, search_func: GCompareFunc, user_data: gconstpointer) -> gpointer;
    pub fn g_tree_steal(tree: *mut GTree, key: gconstpointer) -> gboolean;
    pub fn g_tree_traverse(tree: *mut GTree, traverse_func: GTraverseFunc, traverse_type: GTraverseType, user_data: gpointer);
    pub fn g_tree_unref(tree: *mut GTree);
    pub fn g_tree_new(key_compare_func: GCompareFunc) -> *mut GTree;
    pub fn g_tree_new_full(key_compare_func: GCompareDataFunc, key_compare_data: gpointer, key_destroy_func: GDestroyNotify, value_destroy_func: GDestroyNotify) -> *mut GTree;
    pub fn g_tree_new_with_data(key_compare_func: GCompareDataFunc, key_compare_data: gpointer) -> *mut GTree;

    //=========================================================================
    // GVariant
    //=========================================================================
    pub fn g_variant_new(format_string: *const c_char, ...) -> *mut GVariant;
    pub fn g_variant_new_array(child_type: *const GVariantType, children: *mut *mut GVariant, n_children: size_t) -> *mut GVariant;
    pub fn g_variant_new_boolean(value: gboolean) -> *mut GVariant;
    pub fn g_variant_new_byte(value: c_uchar) -> *mut GVariant;
    pub fn g_variant_new_bytestring(string: *mut u8) -> *mut GVariant;
    pub fn g_variant_new_bytestring_array(strv: *mut *mut c_char, length: ssize_t) -> *mut GVariant;
    pub fn g_variant_new_dict_entry(key: *mut GVariant, value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_new_double(value: c_double) -> *mut GVariant;
    pub fn g_variant_new_fixed_array(element_type: *const GVariantType, elements: gconstpointer, n_elements: size_t, element_size: size_t) -> *mut GVariant;
    #[cfg(any(feature = "v2_36", feature = "dox"))]
    pub fn g_variant_new_from_bytes(type_: *const GVariantType, bytes: *mut GBytes, trusted: gboolean) -> *mut GVariant;
    pub fn g_variant_new_from_data(type_: *const GVariantType, data: gconstpointer, size: size_t, trusted: gboolean, notify: GDestroyNotify, user_data: gpointer) -> *mut GVariant;
    pub fn g_variant_new_handle(value: i32) -> *mut GVariant;
    pub fn g_variant_new_int16(value: i16) -> *mut GVariant;
    pub fn g_variant_new_int32(value: i32) -> *mut GVariant;
    pub fn g_variant_new_int64(value: i64) -> *mut GVariant;
    pub fn g_variant_new_maybe(child_type: *const GVariantType, child: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_new_object_path(object_path: *const c_char) -> *mut GVariant;
    pub fn g_variant_new_objv(strv: *mut *mut c_char, length: ssize_t) -> *mut GVariant;
    pub fn g_variant_new_parsed(format: *const c_char, ...) -> *mut GVariant;
    //pub fn g_variant_new_parsed_va(format: *const c_char, app: /*Unimplemented*/*mut va_list) -> *mut GVariant;
    #[cfg(any(feature = "v2_38", feature = "dox"))]
    pub fn g_variant_new_printf(format_string: *const c_char, ...) -> *mut GVariant;
    pub fn g_variant_new_signature(signature: *const c_char) -> *mut GVariant;
    pub fn g_variant_new_string(string: *const c_char) -> *mut GVariant;
    pub fn g_variant_new_strv(strv: *mut *mut c_char, length: ssize_t) -> *mut GVariant;
    #[cfg(any(feature = "v2_38", feature = "dox"))]
    pub fn g_variant_new_take_string(string: *mut c_char) -> *mut GVariant;
    pub fn g_variant_new_tuple(children: *mut *mut GVariant, n_children: size_t) -> *mut GVariant;
    pub fn g_variant_new_uint16(value: u16) -> *mut GVariant;
    pub fn g_variant_new_uint32(value: u32) -> *mut GVariant;
    pub fn g_variant_new_uint64(value: u64) -> *mut GVariant;
    //pub fn g_variant_new_va(format_string: *const c_char, endptr: *mut *const c_char, app: /*Unimplemented*/*mut va_list) -> *mut GVariant;
    pub fn g_variant_new_variant(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_byteswap(value: *mut GVariant) -> *mut GVariant;
    #[cfg(any(feature = "v2_34", feature = "dox"))]
    pub fn g_variant_check_format_string(value: *mut GVariant, format_string: *const c_char, copy_only: gboolean) -> gboolean;
    pub fn g_variant_classify(value: *mut GVariant) -> GVariantClass;
    pub fn g_variant_compare(one: gconstpointer, two: gconstpointer) -> c_int;
    pub fn g_variant_dup_bytestring(value: *mut GVariant, length: *mut size_t) -> *mut u8;
    pub fn g_variant_dup_bytestring_array(value: *mut GVariant, length: *mut size_t) -> *mut *mut c_char;
    pub fn g_variant_dup_objv(value: *mut GVariant, length: *mut size_t) -> *mut *mut c_char;
    pub fn g_variant_dup_string(value: *mut GVariant, length: *mut size_t) -> *mut c_char;
    pub fn g_variant_dup_strv(value: *mut GVariant, length: *mut size_t) -> *mut *mut c_char;
    pub fn g_variant_equal(one: gconstpointer, two: gconstpointer) -> gboolean;
    pub fn g_variant_get(value: *mut GVariant, format_string: *const c_char, ...);
    pub fn g_variant_get_boolean(value: *mut GVariant) -> gboolean;
    pub fn g_variant_get_byte(value: *mut GVariant) -> c_uchar;
    pub fn g_variant_get_bytestring(value: *mut GVariant) -> *mut u8;
    pub fn g_variant_get_bytestring_array(value: *mut GVariant, length: *mut size_t) -> *mut *mut c_char;
    pub fn g_variant_get_child(value: *mut GVariant, index_: size_t, format_string: *const c_char, ...);
    pub fn g_variant_get_child_value(value: *mut GVariant, index_: size_t) -> *mut GVariant;
    pub fn g_variant_get_data(value: *mut GVariant) -> gconstpointer;
    #[cfg(any(feature = "v2_36", feature = "dox"))]
    pub fn g_variant_get_data_as_bytes(value: *mut GVariant) -> *mut GBytes;
    pub fn g_variant_get_double(value: *mut GVariant) -> c_double;
    pub fn g_variant_get_fixed_array(value: *mut GVariant, n_elements: *mut size_t, element_size: size_t) -> gconstpointer;
    pub fn g_variant_get_handle(value: *mut GVariant) -> i32;
    pub fn g_variant_get_int16(value: *mut GVariant) -> i16;
    pub fn g_variant_get_int32(value: *mut GVariant) -> i32;
    pub fn g_variant_get_int64(value: *mut GVariant) -> i64;
    pub fn g_variant_get_maybe(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_get_normal_form(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_get_objv(value: *mut GVariant, length: *mut size_t) -> *mut *mut c_char;
    pub fn g_variant_get_size(value: *mut GVariant) -> size_t;
    pub fn g_variant_get_string(value: *mut GVariant, length: *mut size_t) -> *const c_char;
    pub fn g_variant_get_strv(value: *mut GVariant, length: *mut size_t) -> *mut *mut c_char;
    pub fn g_variant_get_type(value: *mut GVariant) -> *const GVariantType;
    pub fn g_variant_get_type_string(value: *mut GVariant) -> *const c_char;
    pub fn g_variant_get_uint16(value: *mut GVariant) -> u16;
    pub fn g_variant_get_uint32(value: *mut GVariant) -> u32;
    pub fn g_variant_get_uint64(value: *mut GVariant) -> u64;
    //pub fn g_variant_get_va(value: *mut GVariant, format_string: *const c_char, endptr: *mut *const c_char, app: /*Unimplemented*/*mut va_list);
    pub fn g_variant_get_variant(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_hash(value: gconstpointer) -> c_uint;
    pub fn g_variant_is_container(value: *mut GVariant) -> gboolean;
    pub fn g_variant_is_floating(value: *mut GVariant) -> gboolean;
    pub fn g_variant_is_normal_form(value: *mut GVariant) -> gboolean;
    pub fn g_variant_is_of_type(value: *mut GVariant, type_: *const GVariantType) -> gboolean;
    pub fn g_variant_iter_new(value: *mut GVariant) -> *mut GVariantIter;
    pub fn g_variant_lookup(dictionary: *mut GVariant, key: *const c_char, format_string: *const c_char, ...) -> gboolean;
    pub fn g_variant_lookup_value(dictionary: *mut GVariant, key: *const c_char, expected_type: *const GVariantType) -> *mut GVariant;
    pub fn g_variant_n_children(value: *mut GVariant) -> size_t;
    pub fn g_variant_print(value: *mut GVariant, type_annotate: gboolean) -> *mut c_char;
    pub fn g_variant_print_string(value: *mut GVariant, string: *mut GString, type_annotate: gboolean) -> *mut GString;
    pub fn g_variant_ref(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_ref_sink(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_store(value: *mut GVariant, data: gpointer);
    pub fn g_variant_take_ref(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_unref(value: *mut GVariant);
    pub fn g_variant_is_object_path(string: *const c_char) -> gboolean;
    pub fn g_variant_is_signature(string: *const c_char) -> gboolean;
    pub fn g_variant_parse(type_: *const GVariantType, text: *const c_char, limit: *const c_char, endptr: *mut *const c_char, error: *mut *mut GError) -> *mut GVariant;
    #[cfg(any(feature = "v2_40", feature = "dox"))]
    pub fn g_variant_parse_error_print_context(error: *mut GError, source_str: *const c_char) -> *mut c_char;
    pub fn g_variant_parse_error_quark() -> GQuark;
    pub fn g_variant_parser_get_error_quark() -> GQuark;

    //=========================================================================
    // GVariantBuilder
    //=========================================================================
    pub fn g_variant_builder_get_type() -> GType;
    pub fn g_variant_builder_new(type_: *const GVariantType) -> *mut GVariantBuilder;
    pub fn g_variant_builder_add(builder: *mut GVariantBuilder, format_string: *const c_char, ...);
    pub fn g_variant_builder_add_parsed(builder: *mut GVariantBuilder, format: *const c_char, ...);
    pub fn g_variant_builder_add_value(builder: *mut GVariantBuilder, value: *mut GVariant);
    pub fn g_variant_builder_clear(builder: *mut GVariantBuilder);
    pub fn g_variant_builder_close(builder: *mut GVariantBuilder);
    pub fn g_variant_builder_end(builder: *mut GVariantBuilder) -> *mut GVariant;
    pub fn g_variant_builder_init(builder: *mut GVariantBuilder, type_: *const GVariantType);
    pub fn g_variant_builder_open(builder: *mut GVariantBuilder, type_: *const GVariantType);
    pub fn g_variant_builder_ref(builder: *mut GVariantBuilder) -> *mut GVariantBuilder;
    pub fn g_variant_builder_unref(builder: *mut GVariantBuilder);

    //=========================================================================
    // GVariantDict
    //=========================================================================
    pub fn g_variant_dict_get_type() -> GType;
    #[cfg(any(feature = "v2_40", feature = "dox"))]
    pub fn g_variant_dict_new(from_asv: *mut GVariant) -> *mut GVariantDict;
    #[cfg(any(feature = "v2_40", feature = "dox"))]
    pub fn g_variant_dict_clear(dict: *mut GVariantDict);
    #[cfg(any(feature = "v2_40", feature = "dox"))]
    pub fn g_variant_dict_contains(dict: *mut GVariantDict, key: *const c_char) -> gboolean;
    #[cfg(any(feature = "v2_40", feature = "dox"))]
    pub fn g_variant_dict_end(dict: *mut GVariantDict) -> *mut GVariant;
    #[cfg(any(feature = "v2_40", feature = "dox"))]
    pub fn g_variant_dict_init(dict: *mut GVariantDict, from_asv: *mut GVariant);
    #[cfg(any(feature = "v2_40", feature = "dox"))]
    pub fn g_variant_dict_insert(dict: *mut GVariantDict, key: *const c_char, format_string: *const c_char, ...);
    #[cfg(any(feature = "v2_40", feature = "dox"))]
    pub fn g_variant_dict_insert_value(dict: *mut GVariantDict, key: *const c_char, value: *mut GVariant);
    #[cfg(any(feature = "v2_40", feature = "dox"))]
    pub fn g_variant_dict_lookup(dict: *mut GVariantDict, key: *const c_char, format_string: *const c_char, ...) -> gboolean;
    #[cfg(any(feature = "v2_40", feature = "dox"))]
    pub fn g_variant_dict_lookup_value(dict: *mut GVariantDict, key: *const c_char, expected_type: *const GVariantType) -> *mut GVariant;
    #[cfg(any(feature = "v2_40", feature = "dox"))]
    pub fn g_variant_dict_ref(dict: *mut GVariantDict) -> *mut GVariantDict;
    #[cfg(any(feature = "v2_40", feature = "dox"))]
    pub fn g_variant_dict_remove(dict: *mut GVariantDict, key: *const c_char) -> gboolean;
    #[cfg(any(feature = "v2_40", feature = "dox"))]
    pub fn g_variant_dict_unref(dict: *mut GVariantDict);

    //=========================================================================
    // GVariantIter
    //=========================================================================
    pub fn g_variant_iter_copy(iter: *mut GVariantIter) -> *mut GVariantIter;
    pub fn g_variant_iter_free(iter: *mut GVariantIter);
    pub fn g_variant_iter_init(iter: *mut GVariantIter, value: *mut GVariant) -> size_t;
    pub fn g_variant_iter_loop(iter: *mut GVariantIter, format_string: *const c_char, ...) -> gboolean;
    pub fn g_variant_iter_n_children(iter: *mut GVariantIter) -> size_t;
    pub fn g_variant_iter_next(iter: *mut GVariantIter, format_string: *const c_char, ...) -> gboolean;
    pub fn g_variant_iter_next_value(iter: *mut GVariantIter) -> *mut GVariant;

    //=========================================================================
    // GVariantType
    //=========================================================================
    pub fn g_variant_type_get_gtype() -> GType;
    pub fn g_variant_type_new(type_string: *const c_char) -> *mut GVariantType;
    pub fn g_variant_type_new_array(element: *const GVariantType) -> *mut GVariantType;
    pub fn g_variant_type_new_dict_entry(key: *const GVariantType, value: *const GVariantType) -> *mut GVariantType;
    pub fn g_variant_type_new_maybe(element: *const GVariantType) -> *mut GVariantType;
    pub fn g_variant_type_new_tuple(items: *mut *mut GVariantType, length: c_int) -> *mut GVariantType;
    pub fn g_variant_type_copy(type_: *const GVariantType) -> *mut GVariantType;
    pub fn g_variant_type_dup_string(type_: *const GVariantType) -> *mut c_char;
    pub fn g_variant_type_element(type_: *const GVariantType) -> *const GVariantType;
    pub fn g_variant_type_equal(type1: gconstpointer, type2: gconstpointer) -> gboolean;
    pub fn g_variant_type_first(type_: *const GVariantType) -> *const GVariantType;
    pub fn g_variant_type_free(type_: *mut GVariantType);
    pub fn g_variant_type_get_string_length(type_: *const GVariantType) -> size_t;
    pub fn g_variant_type_hash(type_: gconstpointer) -> c_uint;
    pub fn g_variant_type_is_array(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_basic(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_container(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_definite(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_dict_entry(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_maybe(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_subtype_of(type_: *const GVariantType, supertype: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_tuple(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_variant(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_key(type_: *const GVariantType) -> *const GVariantType;
    pub fn g_variant_type_n_items(type_: *const GVariantType) -> size_t;
    pub fn g_variant_type_next(type_: *const GVariantType) -> *const GVariantType;
    pub fn g_variant_type_peek_string(type_: *const GVariantType) -> *const c_char;
    pub fn g_variant_type_value(type_: *const GVariantType) -> *const GVariantType;
    pub fn g_variant_type_checked_(arg0: *const c_char) -> *const GVariantType;
    pub fn g_variant_type_string_is_valid(type_string: *const c_char) -> gboolean;
    pub fn g_variant_type_string_scan(string: *const c_char, limit: *const c_char, endptr: *mut *const c_char) -> gboolean;

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn g_access(filename: *mut c_char, mode: c_int) -> c_int;
    pub fn g_ascii_digit_value(c: c_char) -> c_int;
    pub fn g_ascii_dtostr(buffer: *mut c_char, buf_len: c_int, d: c_double) -> *mut c_char;
    pub fn g_ascii_formatd(buffer: *mut c_char, buf_len: c_int, format: *const c_char, d: c_double) -> *mut c_char;
    pub fn g_ascii_strcasecmp(s1: *const c_char, s2: *const c_char) -> c_int;
    pub fn g_ascii_strdown(str: *const c_char, len: ssize_t) -> *mut c_char;
    #[cfg(any(feature = "v2_54", feature = "dox"))]
    pub fn g_ascii_string_to_signed(str: *const c_char, base: c_uint, min: i64, max: i64, out_num: *mut i64, error: *mut *mut GError) -> gboolean;
    #[cfg(any(feature = "v2_54", feature = "dox"))]
    pub fn g_ascii_string_to_unsigned(str: *const c_char, base: c_uint, min: u64, max: u64, out_num: *mut u64, error: *mut *mut GError) -> gboolean;
    pub fn g_ascii_strncasecmp(s1: *const c_char, s2: *const c_char, n: size_t) -> c_int;
    pub fn g_ascii_strtod(nptr: *const c_char, endptr: *mut *mut c_char) -> c_double;
    pub fn g_ascii_strtoll(nptr: *const c_char, endptr: *mut *mut c_char, base: c_uint) -> i64;
    pub fn g_ascii_strtoull(nptr: *const c_char, endptr: *mut *mut c_char, base: c_uint) -> u64;
    pub fn g_ascii_strup(str: *const c_char, len: ssize_t) -> *mut c_char;
    pub fn g_ascii_tolower(c: c_char) -> c_char;
    pub fn g_ascii_toupper(c: c_char) -> c_char;
    pub fn g_ascii_xdigit_value(c: c_char) -> c_int;
    pub fn g_assert_warning(log_domain: *const c_char, file: *const c_char, line: c_int, pretty_function: *const c_char, expression: *const c_char);
    pub fn g_assertion_message(domain: *const c_char, file: *const c_char, line: c_int, func: *const c_char, message: *const c_char);
    //pub fn g_assertion_message_cmpnum(domain: *const c_char, file: *const c_char, line: c_int, func: *const c_char, expr: *const c_char, arg1: /*Unimplemented*/long double, cmp: *const c_char, arg2: /*Unimplemented*/long double, numtype: c_char);
    pub fn g_assertion_message_cmpstr(domain: *const c_char, file: *const c_char, line: c_int, func: *const c_char, expr: *const c_char, arg1: *const c_char, cmp: *const c_char, arg2: *const c_char);
    pub fn g_assertion_message_error(domain: *const c_char, file: *const c_char, line: c_int, func: *const c_char, expr: *const c_char, error: *const GError, error_domain: GQuark, error_code: c_int);
    pub fn g_assertion_message_expr(domain: *const c_char, file: *const c_char, line: c_int, func: *const c_char, expr: *const c_char);
    pub fn g_atexit(func: GVoidFunc);
    pub fn g_atomic_int_add(atomic: *mut Volatile<c_int>, val: c_int) -> c_int;
    pub fn g_atomic_int_and(atomic: *mut Volatile<c_uint>, val: c_uint) -> c_uint;
    pub fn g_atomic_int_compare_and_exchange(atomic: *mut Volatile<c_int>, oldval: c_int, newval: c_int) -> gboolean;
    pub fn g_atomic_int_dec_and_test(atomic: *mut Volatile<c_int>) -> gboolean;
    pub fn g_atomic_int_exchange_and_add(atomic: *mut Volatile<c_int>, val: c_int) -> c_int;
    pub fn g_atomic_int_get(atomic: *const c_int) -> c_int;
    pub fn g_atomic_int_inc(atomic: *mut Volatile<c_int>);
    pub fn g_atomic_int_or(atomic: *mut Volatile<c_uint>, val: c_uint) -> c_uint;
    pub fn g_atomic_int_set(atomic: *mut Volatile<c_int>, newval: c_int);
    pub fn g_atomic_int_xor(atomic: *mut Volatile<c_uint>, val: c_uint) -> c_uint;
    pub fn g_atomic_pointer_add(atomic: *mut c_void, val: ssize_t) -> ssize_t;
    pub fn g_atomic_pointer_and(atomic: *mut c_void, val: size_t) -> size_t;
    pub fn g_atomic_pointer_compare_and_exchange(atomic: *mut c_void, oldval: gpointer, newval: gpointer) -> gboolean;
    pub fn g_atomic_pointer_get(atomic: *mut c_void) -> gpointer;
    pub fn g_atomic_pointer_or(atomic: *mut c_void, val: size_t) -> size_t;
    pub fn g_atomic_pointer_set(atomic: *mut c_void, newval: gpointer);
    pub fn g_atomic_pointer_xor(atomic: *mut c_void, val: size_t) -> size_t;
    pub fn g_base64_decode(text: *const c_char, out_len: *mut size_t) -> *mut u8;
    pub fn g_base64_decode_inplace(text: *mut u8, out_len: *mut size_t) -> *mut u8;
    pub fn g_base64_decode_step(in_: *mut u8, len: size_t, out: *mut u8, state: *mut c_int, save: *mut c_uint) -> size_t;
    pub fn g_base64_encode(data: *mut u8, len: size_t) -> *mut c_char;
    pub fn g_base64_encode_close(break_lines: gboolean, out: *mut u8, state: *mut c_int, save: *mut c_int) -> size_t;
    pub fn g_base64_encode_step(in_: *mut u8, len: size_t, break_lines: gboolean, out: *mut u8, state: *mut c_int, save: *mut c_int) -> size_t;
    pub fn g_basename(file_name: *mut c_char) -> *mut c_char;
    pub fn g_bit_lock(address: *mut Volatile<c_int>, lock_bit: c_int);
    pub fn g_bit_nth_lsf(mask: c_ulong, nth_bit: c_int) -> c_int;
    pub fn g_bit_nth_msf(mask: c_ulong, nth_bit: c_int) -> c_int;
    pub fn g_bit_storage(number: c_ulong) -> c_uint;
    pub fn g_bit_trylock(address: *mut Volatile<c_int>, lock_bit: c_int) -> gboolean;
    pub fn g_bit_unlock(address: *mut Volatile<c_int>, lock_bit: c_int);
    pub fn g_build_filename(first_element: *mut c_char, ...) -> *mut c_char;
    pub fn g_build_filenamev(args: *mut *mut c_char) -> *mut c_char;
    pub fn g_build_path(separator: *mut c_char, first_element: *mut c_char, ...) -> *mut c_char;
    pub fn g_build_pathv(separator: *const c_char, args: *mut *mut c_char) -> *mut c_char;
    pub fn g_chdir(path: *mut c_char) -> c_int;
    pub fn glib_check_version(required_major: c_uint, required_minor: c_uint, required_micro: c_uint) -> *const c_char;
    pub fn g_child_watch_add(pid: GPid, function: GChildWatchFunc, data: gpointer) -> c_uint;
    pub fn g_child_watch_add_full(priority: c_int, pid: GPid, function: GChildWatchFunc, data: gpointer, notify: GDestroyNotify) -> c_uint;
    pub fn g_child_watch_source_new(pid: GPid) -> *mut GSource;
    pub fn g_clear_error(error: *mut *mut GError);
    #[cfg(any(feature = "v2_34", feature = "dox"))]
    pub fn g_clear_pointer(pp: *mut gpointer, destroy: GDestroyNotify);
    #[cfg(any(feature = "v2_36", feature = "dox"))]
    pub fn g_close(fd: c_int, error: *mut *mut GError) -> gboolean;
    #[cfg(any(feature = "v2_34", feature = "dox"))]
    pub fn g_compute_checksum_for_bytes(checksum_type: GChecksumType, data: *mut GBytes) -> *mut c_char;
    pub fn g_compute_checksum_for_data(checksum_type: GChecksumType, data: *mut u8, length: size_t) -> *mut c_char;
    pub fn g_compute_checksum_for_string(checksum_type: GChecksumType, str: *const c_char, length: ssize_t) -> *mut c_char;
    #[cfg(any(feature = "v2_50", feature = "dox"))]
    pub fn g_compute_hmac_for_bytes(digest_type: GChecksumType, key: *mut GBytes, data: *mut GBytes) -> *mut c_char;
    pub fn g_compute_hmac_for_data(digest_type: GChecksumType, key: *mut u8, key_len: size_t, data: *mut u8, length: size_t) -> *mut c_char;
    pub fn g_compute_hmac_for_string(digest_type: GChecksumType, key: *mut u8, key_len: size_t, str: *const c_char, length: ssize_t) -> *mut c_char;
    pub fn g_convert(str: *const c_char, len: ssize_t, to_codeset: *const c_char, from_codeset: *const c_char, bytes_read: *mut size_t, bytes_written: *mut size_t, error: *mut *mut GError) -> *mut c_char;
    pub fn g_convert_error_quark() -> GQuark;
    pub fn g_convert_with_fallback(str: *const c_char, len: ssize_t, to_codeset: *const c_char, from_codeset: *const c_char, fallback: *const c_char, bytes_read: *mut size_t, bytes_written: *mut size_t, error: *mut *mut GError) -> *mut c_char;
    pub fn g_convert_with_iconv(str: *const c_char, len: ssize_t, converter: GIConv, bytes_read: *mut size_t, bytes_written: *mut size_t, error: *mut *mut GError) -> *mut c_char;
    pub fn g_datalist_clear(datalist: *mut *mut GData);
    pub fn g_datalist_foreach(datalist: *mut *mut GData, func: GDataForeachFunc, user_data: gpointer);
    pub fn g_datalist_get_data(datalist: *mut *mut GData, key: *const c_char) -> gpointer;
    pub fn g_datalist_get_flags(datalist: *mut *mut GData) -> c_uint;
    #[cfg(any(feature = "v2_34", feature = "dox"))]
    pub fn g_datalist_id_dup_data(datalist: *mut *mut GData, key_id: GQuark, dup_func: GDuplicateFunc, user_data: gpointer) -> gpointer;
    pub fn g_datalist_id_get_data(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
    pub fn g_datalist_id_remove_no_notify(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
    #[cfg(any(feature = "v2_34", feature = "dox"))]
    pub fn g_datalist_id_replace_data(datalist: *mut *mut GData, key_id: GQuark, oldval: gpointer, newval: gpointer, destroy: GDestroyNotify, old_destroy: *mut GDestroyNotify) -> gboolean;
    pub fn g_datalist_id_set_data_full(datalist: *mut *mut GData, key_id: GQuark, data: gpointer, destroy_func: GDestroyNotify);
    pub fn g_datalist_init(datalist: *mut *mut GData);
    pub fn g_datalist_set_flags(datalist: *mut *mut GData, flags: c_uint);
    pub fn g_datalist_unset_flags(datalist: *mut *mut GData, flags: c_uint);
    pub fn g_dataset_destroy(dataset_location: gconstpointer);
    pub fn g_dataset_foreach(dataset_location: gconstpointer, func: GDataForeachFunc, user_data: gpointer);
    pub fn g_dataset_id_get_data(dataset_location: gconstpointer, key_id: GQuark) -> gpointer;
    pub fn g_dataset_id_remove_no_notify(dataset_location: gconstpointer, key_id: GQuark) -> gpointer;
    pub fn g_dataset_id_set_data_full(dataset_location: gconstpointer, key_id: GQuark, data: gpointer, destroy_func: GDestroyNotify);
    pub fn g_dcgettext(domain: *const c_char, msgid: *const c_char, category: c_int) -> *const c_char;
    pub fn g_dgettext(domain: *const c_char, msgid: *const c_char) -> *const c_char;
    pub fn g_direct_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_direct_hash(v: gconstpointer) -> c_uint;
    pub fn g_dngettext(domain: *const c_char, msgid: *const c_char, msgid_plural: *const c_char, n: c_ulong) -> *const c_char;
    pub fn g_double_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_double_hash(v: gconstpointer) -> c_uint;
    pub fn g_dpgettext(domain: *const c_char, msgctxtid: *const c_char, msgidoffset: size_t) -> *const c_char;
    pub fn g_dpgettext2(domain: *const c_char, context: *const c_char, msgid: *const c_char) -> *const c_char;
    pub fn g_environ_getenv(envp: *mut *mut c_char, variable: *const c_char) -> *const c_char;
    pub fn g_environ_setenv(envp: *mut *mut c_char, variable: *const c_char, value: *const c_char, overwrite: gboolean) -> *mut *mut c_char;
    pub fn g_environ_unsetenv(envp: *mut *mut c_char, variable: *const c_char) -> *mut *mut c_char;
    pub fn g_file_error_from_errno(err_no: c_int) -> GFileError;
    pub fn g_file_error_quark() -> GQuark;
    #[cfg(any(windows, feature = "dox"))]
    pub fn g_file_get_contents_utf8(filename: *mut c_char, contents: *mut *mut u8, length: *mut size_t, error: *mut *mut GError) -> gboolean;
    pub fn g_file_get_contents(filename: *mut c_char, contents: *mut *mut u8, length: *mut size_t, error: *mut *mut GError) -> gboolean;
    #[cfg(any(windows, feature = "dox"))]
    pub fn g_file_open_tmp_utf8(tmpl: *mut c_char, name_used: *mut *mut c_char, error: *mut *mut GError) -> c_int;
    pub fn g_file_open_tmp(tmpl: *mut c_char, name_used: *mut *mut c_char, error: *mut *mut GError) -> c_int;
    pub fn g_file_read_link(filename: *mut c_char, error: *mut *mut GError) -> *mut c_char;
    pub fn g_file_set_contents(filename: *mut c_char, contents: *mut u8, length: ssize_t, error: *mut *mut GError) -> gboolean;
    #[cfg(any(windows, feature = "dox"))]
    pub fn g_file_test_utf8(filename: *mut c_char, test: GFileTest) -> gboolean;
    pub fn g_file_test(filename: *mut c_char, test: GFileTest) -> gboolean;
    pub fn g_filename_display_basename(filename: *mut c_char) -> *mut c_char;
    pub fn g_filename_display_name(filename: *mut c_char) -> *mut c_char;
    #[cfg(any(windows, feature = "dox"))]
    pub fn g_filename_from_uri_utf8(uri: *const c_char, hostname: *mut *mut c_char, error: *mut *mut GError) -> *mut c_char;
    pub fn g_filename_from_uri(uri: *const c_char, hostname: *mut *mut c_char, error: *mut *mut GError) -> *mut c_char;
    #[cfg(any(windows, feature = "dox"))]
    pub fn g_filename_from_utf8_utf8(utf8string: *const c_char, len: ssize_t, bytes_read: *mut size_t, bytes_written: *mut size_t, error: *mut *mut GError) -> *mut u8;
    pub fn g_filename_from_utf8(utf8string: *const c_char, len: ssize_t, bytes_read: *mut size_t, bytes_written: *mut size_t, error: *mut *mut GError) -> *mut u8;
    #[cfg(any(windows, feature = "dox"))]
    pub fn g_filename_to_uri_utf8(filename: *mut c_char, hostname: *const c_char, error: *mut *mut GError) -> *mut c_char;
    pub fn g_filename_to_uri(filename: *mut c_char, hostname: *const c_char, error: *mut *mut GError) -> *mut c_char;
    #[cfg(any(windows, feature = "dox"))]
    pub fn g_filename_to_utf8_utf8(opsysstring: *mut c_char, len: ssize_t, bytes_read: *mut size_t, bytes_written: *mut size_t, error: *mut *mut GError) -> *mut c_char;
    pub fn g_filename_to_utf8(opsysstring: *mut c_char, len: ssize_t, bytes_read: *mut size_t, bytes_written: *mut size_t, error: *mut *mut GError) -> *mut c_char;
    #[cfg(any(windows, feature = "dox"))]
    pub fn g_find_program_in_path_utf8(program: *mut c_char) -> *mut c_char;
    pub fn g_find_program_in_path(program: *mut c_char) -> *mut c_char;
    pub fn g_format_size(size: u64) -> *mut c_char;
    pub fn g_format_size_for_display(size: i64) -> *mut c_char;
    pub fn g_format_size_full(size: u64, flags: GFormatSizeFlags) -> *mut c_char;
    pub fn g_fprintf(file: *mut FILE, format: *mut c_char, ...) -> c_int;
    pub fn g_free(mem: gpointer);
    pub fn g_get_application_name() -> *const c_char;
    pub fn g_get_charset(charset: *mut *const c_char) -> gboolean;
    pub fn g_get_codeset() -> *mut c_char;
    #[cfg(any(windows, feature = "dox"))]
    pub fn g_get_current_dir_utf8() -> *mut c_char;
    pub fn g_get_current_dir() -> *mut c_char;
    pub fn g_get_current_time(result: *mut GTimeVal);
    pub fn g_get_environ() -> *mut *mut c_char;
    pub fn g_get_filename_charsets(charsets: *mut *mut *const c_char) -> gboolean;
    #[cfg(any(windows, feature = "dox"))]
    pub fn g_get_home_dir_utf8() -> *mut c_char;
    pub fn g_get_home_dir() -> *mut c_char;
    pub fn g_get_host_name() -> *const c_char;
    pub fn g_get_language_names() -> *mut *mut c_char;
    pub fn g_get_locale_variants(locale: *const c_char) -> *mut *mut c_char;
    pub fn g_get_monotonic_time() -> i64;
    #[cfg(any(feature = "v2_36", feature = "dox"))]
    pub fn g_get_num_processors() -> c_uint;
    pub fn g_get_prgname() -> *const c_char;
    #[cfg(any(windows, feature = "dox"))]
    pub fn g_get_real_name_utf8() -> *mut c_char;
    pub fn g_get_real_name() -> *mut c_char;
    pub fn g_get_real_time() -> i64;
    pub fn g_get_system_config_dirs() -> *mut *mut c_char;
    pub fn g_get_system_data_dirs() -> *mut *mut c_char;
    #[cfg(any(windows, feature = "dox"))]
    pub fn g_get_tmp_dir_utf8() -> *mut c_char;
    pub fn g_get_tmp_dir() -> *mut c_char;
    pub fn g_get_user_cache_dir() -> *mut c_char;
    pub fn g_get_user_config_dir() -> *mut c_char;
    pub fn g_get_user_data_dir() -> *mut c_char;
    #[cfg(any(windows, feature = "dox"))]
    pub fn g_get_user_name_utf8() -> *mut c_char;
    pub fn g_get_user_name() -> *mut c_char;
    pub fn g_get_user_runtime_dir() -> *mut c_char;
    pub fn g_get_user_special_dir(directory: GUserDirectory) -> *mut c_char;
    #[cfg(any(windows, feature = "dox"))]
    pub fn g_getenv_utf8(variable: *const c_char) -> *const c_char;
    pub fn g_getenv(variable: *const c_char) -> *const c_char;
    pub fn g_hostname_is_ascii_encoded(hostname: *const c_char) -> gboolean;
    pub fn g_hostname_is_ip_address(hostname: *const c_char) -> gboolean;
    pub fn g_hostname_is_non_ascii(hostname: *const c_char) -> gboolean;
    pub fn g_hostname_to_ascii(hostname: *const c_char) -> *mut c_char;
    pub fn g_hostname_to_unicode(hostname: *const c_char) -> *mut c_char;
    pub fn g_iconv(converter: GIConv, inbuf: *mut *mut c_char, inbytes_left: *mut size_t, outbuf: *mut *mut c_char, outbytes_left: *mut size_t) -> size_t;
    pub fn g_idle_add(function: GSourceFunc, data: gpointer) -> c_uint;
    pub fn g_idle_add_full(priority: c_int, function: GSourceFunc, data: gpointer, notify: GDestroyNotify) -> c_uint;
    pub fn g_idle_remove_by_data(data: gpointer) -> gboolean;
    pub fn g_idle_source_new() -> *mut GSource;
    pub fn g_int64_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_int64_hash(v: gconstpointer) -> c_uint;
    pub fn g_int_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_int_hash(v: gconstpointer) -> c_uint;
    pub fn g_intern_static_string(string: *const c_char) -> *const c_char;
    pub fn g_intern_string(string: *const c_char) -> *const c_char;
    pub fn g_io_add_watch(channel: *mut GIOChannel, condition: GIOCondition, func: GIOFunc, user_data: gpointer) -> c_uint;
    pub fn g_io_add_watch_full(channel: *mut GIOChannel, priority: c_int, condition: GIOCondition, func: GIOFunc, user_data: gpointer, notify: GDestroyNotify) -> c_uint;
    pub fn g_io_create_watch(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource;
    pub fn g_listenv() -> *mut *mut c_char;
    pub fn g_locale_from_utf8(utf8string: *const c_char, len: ssize_t, bytes_read: *mut size_t, bytes_written: *mut size_t, error: *mut *mut GError) -> *mut c_char;
    pub fn g_locale_to_utf8(opsysstring: *const c_char, len: ssize_t, bytes_read: *mut size_t, bytes_written: *mut size_t, error: *mut *mut GError) -> *mut c_char;
    pub fn g_log(log_domain: *const c_char, log_level: GLogLevelFlags, format: *const c_char, ...);
    pub fn g_log_default_handler(log_domain: *const c_char, log_level: GLogLevelFlags, message: *const c_char, unused_data: gpointer);
    pub fn g_log_remove_handler(log_domain: *const c_char, handler_id: c_uint);
    pub fn g_log_set_always_fatal(fatal_mask: GLogLevelFlags) -> GLogLevelFlags;
    pub fn g_log_set_default_handler(log_func: GLogFunc, user_data: gpointer) -> GLogFunc;
    pub fn g_log_set_fatal_mask(log_domain: *const c_char, fatal_mask: GLogLevelFlags) -> GLogLevelFlags;
    pub fn g_log_set_handler(log_domain: *const c_char, log_levels: GLogLevelFlags, log_func: GLogFunc, user_data: gpointer) -> c_uint;
    #[cfg(any(feature = "v2_46", feature = "dox"))]
    pub fn g_log_set_handler_full(log_domain: *const c_char, log_levels: GLogLevelFlags, log_func: GLogFunc, user_data: gpointer, destroy: GDestroyNotify) -> c_uint;
    #[cfg(any(feature = "v2_50", feature = "dox"))]
    pub fn g_log_set_writer_func(func: GLogWriterFunc, user_data: gpointer, user_data_free: GDestroyNotify);
    #[cfg(any(feature = "v2_50", feature = "dox"))]
    pub fn g_log_structured(log_domain: *const c_char, log_level: GLogLevelFlags, ...);
    #[cfg(any(feature = "v2_50", feature = "dox"))]
    pub fn g_log_structured_array(log_level: GLogLevelFlags, fields: *mut GLogField, n_fields: size_t);
    #[cfg(any(feature = "v2_50", feature = "dox"))]
    pub fn g_log_variant(log_domain: *const c_char, log_level: GLogLevelFlags, fields: *mut GVariant);
    #[cfg(any(feature = "v2_50", feature = "dox"))]
    pub fn g_log_writer_default(log_level: GLogLevelFlags, fields: *mut GLogField, n_fields: size_t, user_data: gpointer) -> GLogWriterOutput;
    #[cfg(any(feature = "v2_50", feature = "dox"))]
    pub fn g_log_writer_format_fields(log_level: GLogLevelFlags, fields: *mut GLogField, n_fields: size_t, use_color: gboolean) -> *mut c_char;
    #[cfg(any(feature = "v2_50", feature = "dox"))]
    pub fn g_log_writer_is_journald(output_fd: c_int) -> gboolean;
    #[cfg(any(feature = "v2_50", feature = "dox"))]
    pub fn g_log_writer_journald(log_level: GLogLevelFlags, fields: *mut GLogField, n_fields: size_t, user_data: gpointer) -> GLogWriterOutput;
    #[cfg(any(feature = "v2_50", feature = "dox"))]
    pub fn g_log_writer_standard_streams(log_level: GLogLevelFlags, fields: *mut GLogField, n_fields: size_t, user_data: gpointer) -> GLogWriterOutput;
    #[cfg(any(feature = "v2_50", feature = "dox"))]
    pub fn g_log_writer_supports_color(output_fd: c_int) -> gboolean;
    //pub fn g_logv(log_domain: *const c_char, log_level: GLogLevelFlags, format: *const c_char, args: /*Unimplemented*/va_list);
    pub fn g_main_current_source() -> *mut GSource;
    pub fn g_main_depth() -> c_int;
    pub fn g_malloc(n_bytes: size_t) -> gpointer;
    pub fn g_malloc0(n_bytes: size_t) -> gpointer;
    pub fn g_malloc0_n(n_blocks: size_t, n_block_bytes: size_t) -> gpointer;
    pub fn g_malloc_n(n_blocks: size_t, n_block_bytes: size_t) -> gpointer;
    pub fn g_markup_collect_attributes(element_name: *const c_char, attribute_names: *mut *const c_char, attribute_values: *mut *const c_char, error: *mut *mut GError, first_type: GMarkupCollectType, first_attr: *const c_char, ...) -> gboolean;
    pub fn g_markup_error_quark() -> GQuark;
    pub fn g_markup_escape_text(text: *const c_char, length: ssize_t) -> *mut c_char;
    pub fn g_markup_printf_escaped(format: *const c_char, ...) -> *mut c_char;
    //pub fn g_markup_vprintf_escaped(format: *const c_char, args: /*Unimplemented*/va_list) -> *mut c_char;
    pub fn g_mem_is_system_malloc() -> gboolean;
    pub fn g_mem_profile();
    pub fn g_mem_set_vtable(vtable: *mut GMemVTable);
    pub fn g_memdup(mem: gconstpointer, byte_size: c_uint) -> gpointer;
    pub fn g_mkdir_with_parents(pathname: *mut c_char, mode: c_int) -> c_int;
    pub fn g_mkdtemp(tmpl: *mut c_char) -> *mut c_char;
    pub fn g_mkdtemp_full(tmpl: *mut c_char, mode: c_int) -> *mut c_char;
    #[cfg(any(windows, feature = "dox"))]
    pub fn g_mkstemp_utf8(tmpl: *mut c_char) -> c_int;
    pub fn g_mkstemp(tmpl: *mut c_char) -> c_int;
    pub fn g_mkstemp_full(tmpl: *mut c_char, flags: c_int, mode: c_int) -> c_int;
    pub fn g_nullify_pointer(nullify_location: *mut gpointer);
    pub fn g_number_parser_error_quark() -> GQuark;
    pub fn g_on_error_query(prg_name: *const c_char);
    pub fn g_on_error_stack_trace(prg_name: *const c_char);
    pub fn g_option_error_quark() -> GQuark;
    pub fn g_parse_debug_string(string: *const c_char, keys: *mut GDebugKey, nkeys: c_uint) -> c_uint;
    pub fn g_path_get_basename(file_name: *mut c_char) -> *mut c_char;
    pub fn g_path_get_dirname(file_name: *mut c_char) -> *mut c_char;
    pub fn g_path_is_absolute(file_name: *mut c_char) -> gboolean;
    pub fn g_path_skip_root(file_name: *mut c_char) -> *mut c_char;
    pub fn g_pattern_match(pspec: *mut GPatternSpec, string_length: c_uint, string: *const c_char, string_reversed: *const c_char) -> gboolean;
    pub fn g_pattern_match_simple(pattern: *const c_char, string: *const c_char) -> gboolean;
    pub fn g_pattern_match_string(pspec: *mut GPatternSpec, string: *const c_char) -> gboolean;
    pub fn g_pointer_bit_lock(address: *mut c_void, lock_bit: c_int);
    pub fn g_pointer_bit_trylock(address: *mut c_void, lock_bit: c_int) -> gboolean;
    pub fn g_pointer_bit_unlock(address: *mut c_void, lock_bit: c_int);
    pub fn g_poll(fds: *mut GPollFD, nfds: c_uint, timeout: c_int) -> c_int;
    pub fn g_prefix_error(err: *mut *mut GError, format: *const c_char, ...);
    pub fn g_print(format: *const c_char, ...);
    pub fn g_printerr(format: *const c_char, ...);
    pub fn g_printf(format: *mut c_char, ...) -> c_int;
    //pub fn g_printf_string_upper_bound(format: *const c_char, args: /*Unimplemented*/va_list) -> size_t;
    pub fn g_propagate_error(dest: *mut *mut GError, src: *mut GError);
    pub fn g_propagate_prefixed_error(dest: *mut *mut GError, src: *mut GError, format: *const c_char, ...);
    pub fn g_qsort_with_data(pbase: gconstpointer, total_elems: c_int, size: size_t, compare_func: GCompareDataFunc, user_data: gpointer);
    pub fn g_quark_from_static_string(string: *const c_char) -> GQuark;
    pub fn g_quark_from_string(string: *const c_char) -> GQuark;
    pub fn g_quark_to_string(quark: GQuark) -> *const c_char;
    pub fn g_quark_try_string(string: *const c_char) -> GQuark;
    pub fn g_random_double() -> c_double;
    pub fn g_random_double_range(begin: c_double, end: c_double) -> c_double;
    pub fn g_random_int() -> u32;
    pub fn g_random_int_range(begin: i32, end: i32) -> i32;
    pub fn g_random_set_seed(seed: u32);
    pub fn g_realloc(mem: gpointer, n_bytes: size_t) -> gpointer;
    pub fn g_realloc_n(mem: gpointer, n_blocks: size_t, n_block_bytes: size_t) -> gpointer;
    pub fn g_reload_user_special_dirs_cache();
    pub fn g_return_if_fail_warning(log_domain: *const c_char, pretty_function: *const c_char, expression: *const c_char);
    pub fn g_rmdir(filename: *mut c_char) -> c_int;
    pub fn g_set_application_name(application_name: *const c_char);
    pub fn g_set_error(err: *mut *mut GError, domain: GQuark, code: c_int, format: *const c_char, ...);
    pub fn g_set_error_literal(err: *mut *mut GError, domain: GQuark, code: c_int, message: *const c_char);
    pub fn g_set_prgname(prgname: *const c_char);
    pub fn g_set_print_handler(func: GPrintFunc) -> GPrintFunc;
    pub fn g_set_printerr_handler(func: GPrintFunc) -> GPrintFunc;
    #[cfg(any(windows, feature = "dox"))]
    pub fn g_setenv_utf8(variable: *const c_char, value: *const c_char, overwrite: gboolean) -> gboolean;
    pub fn g_setenv(variable: *const c_char, value: *const c_char, overwrite: gboolean) -> gboolean;
    pub fn g_shell_error_quark() -> GQuark;
    pub fn g_shell_parse_argv(command_line: *const c_char, argcp: *mut c_int, argvp: *mut *mut *mut c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_shell_quote(unquoted_string: *const c_char) -> *mut c_char;
    pub fn g_shell_unquote(quoted_string: *const c_char, error: *mut *mut GError) -> *mut c_char;
    pub fn g_slice_alloc(block_size: size_t) -> gpointer;
    pub fn g_slice_alloc0(block_size: size_t) -> gpointer;
    pub fn g_slice_copy(block_size: size_t, mem_block: gconstpointer) -> gpointer;
    pub fn g_slice_free1(block_size: size_t, mem_block: gpointer);
    pub fn g_slice_free_chain_with_offset(block_size: size_t, mem_chain: gpointer, next_offset: size_t);
    pub fn g_slice_get_config(ckey: GSliceConfig) -> i64;
    pub fn g_slice_get_config_state(ckey: GSliceConfig, address: i64, n_values: *mut c_uint) -> *mut i64;
    pub fn g_slice_set_config(ckey: GSliceConfig, value: i64);
    pub fn g_snprintf(string: *mut c_char, n: c_ulong, format: *mut c_char, ...) -> c_int;
    pub fn g_spaced_primes_closest(num: c_uint) -> c_uint;
    #[cfg(any(windows, feature = "dox"))]
    pub fn g_spawn_async_utf8(working_directory: *mut c_char, argv: *mut *mut c_char, envp: *mut *mut c_char, flags: GSpawnFlags, child_setup: GSpawnChildSetupFunc, user_data: gpointer, child_pid: *mut GPid, error: *mut *mut GError) -> gboolean;
    pub fn g_spawn_async(working_directory: *mut c_char, argv: *mut *mut c_char, envp: *mut *mut c_char, flags: GSpawnFlags, child_setup: GSpawnChildSetupFunc, user_data: gpointer, child_pid: *mut GPid, error: *mut *mut GError) -> gboolean;
    #[cfg(any(windows, feature = "dox"))]
    pub fn g_spawn_async_with_pipes_utf8(working_directory: *mut c_char, argv: *mut *mut c_char, envp: *mut *mut c_char, flags: GSpawnFlags, child_setup: GSpawnChildSetupFunc, user_data: gpointer, child_pid: *mut GPid, standard_input: *mut c_int, standard_output: *mut c_int, standard_error: *mut c_int, error: *mut *mut GError) -> gboolean;
    pub fn g_spawn_async_with_pipes(working_directory: *mut c_char, argv: *mut *mut c_char, envp: *mut *mut c_char, flags: GSpawnFlags, child_setup: GSpawnChildSetupFunc, user_data: gpointer, child_pid: *mut GPid, standard_input: *mut c_int, standard_output: *mut c_int, standard_error: *mut c_int, error: *mut *mut GError) -> gboolean;
    #[cfg(any(feature = "v2_34", feature = "dox"))]
    pub fn g_spawn_check_exit_status(exit_status: c_int, error: *mut *mut GError) -> gboolean;
    pub fn g_spawn_close_pid(pid: GPid);
    #[cfg(any(windows, feature = "dox"))]
    pub fn g_spawn_command_line_async_utf8(command_line: *const c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_spawn_command_line_async(command_line: *const c_char, error: *mut *mut GError) -> gboolean;
    #[cfg(any(windows, feature = "dox"))]
    pub fn g_spawn_command_line_sync_utf8(command_line: *const c_char, standard_output: *mut *mut u8, standard_error: *mut *mut u8, exit_status: *mut c_int, error: *mut *mut GError) -> gboolean;
    pub fn g_spawn_command_line_sync(command_line: *const c_char, standard_output: *mut *mut u8, standard_error: *mut *mut u8, exit_status: *mut c_int, error: *mut *mut GError) -> gboolean;
    pub fn g_spawn_error_quark() -> GQuark;
    pub fn g_spawn_exit_error_quark() -> GQuark;
    #[cfg(any(windows, feature = "dox"))]
    pub fn g_spawn_sync_utf8(working_directory: *mut c_char, argv: *mut *mut c_char, envp: *mut *mut c_char, flags: GSpawnFlags, child_setup: GSpawnChildSetupFunc, user_data: gpointer, standard_output: *mut *mut u8, standard_error: *mut *mut u8, exit_status: *mut c_int, error: *mut *mut GError) -> gboolean;
    pub fn g_spawn_sync(working_directory: *mut c_char, argv: *mut *mut c_char, envp: *mut *mut c_char, flags: GSpawnFlags, child_setup: GSpawnChildSetupFunc, user_data: gpointer, standard_output: *mut *mut u8, standard_error: *mut *mut u8, exit_status: *mut c_int, error: *mut *mut GError) -> gboolean;
    pub fn g_sprintf(string: *mut c_char, format: *mut c_char, ...) -> c_int;
    pub fn g_stpcpy(dest: *mut c_char, src: *const c_char) -> *mut c_char;
    pub fn g_str_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_str_has_prefix(str: *const c_char, prefix: *const c_char) -> gboolean;
    pub fn g_str_has_suffix(str: *const c_char, suffix: *const c_char) -> gboolean;
    pub fn g_str_hash(v: gconstpointer) -> c_uint;
    #[cfg(any(feature = "v2_40", feature = "dox"))]
    pub fn g_str_is_ascii(str: *const c_char) -> gboolean;
    #[cfg(any(feature = "v2_40", feature = "dox"))]
    pub fn g_str_match_string(search_term: *const c_char, potential_hit: *const c_char, accept_alternates: gboolean) -> gboolean;
    #[cfg(any(feature = "v2_40", feature = "dox"))]
    pub fn g_str_to_ascii(str: *const c_char, from_locale: *const c_char) -> *mut c_char;
    #[cfg(any(feature = "v2_40", feature = "dox"))]
    pub fn g_str_tokenize_and_fold(string: *const c_char, translit_locale: *const c_char, ascii_alternates: *mut *mut *mut c_char) -> *mut *mut c_char;
    pub fn g_strcanon(string: *mut c_char, valid_chars: *const c_char, substitutor: c_char) -> *mut c_char;
    pub fn g_strcasecmp(s1: *const c_char, s2: *const c_char) -> c_int;
    pub fn g_strchomp(string: *mut c_char) -> *mut c_char;
    pub fn g_strchug(string: *mut c_char) -> *mut c_char;
    pub fn g_strcmp0(str1: *const c_char, str2: *const c_char) -> c_int;
    pub fn g_strcompress(source: *const c_char) -> *mut c_char;
    pub fn g_strconcat(string1: *const c_char, ...) -> *mut c_char;
    pub fn g_strdelimit(string: *mut c_char, delimiters: *const c_char, new_delimiter: c_char) -> *mut c_char;
    pub fn g_strdown(string: *mut c_char) -> *mut c_char;
    pub fn g_strdup(str: *const c_char) -> *mut c_char;
    pub fn g_strdup_printf(format: *const c_char, ...) -> *mut c_char;
    //pub fn g_strdup_vprintf(format: *const c_char, args: /*Unimplemented*/va_list) -> *mut c_char;
    pub fn g_strdupv(str_array: *mut *mut c_char) -> *mut *mut c_char;
    pub fn g_strerror(errnum: c_int) -> *const c_char;
    pub fn g_strescape(source: *const c_char, exceptions: *const c_char) -> *mut c_char;
    pub fn g_strfreev(str_array: *mut *mut c_char);
    pub fn g_string_new(init: *const c_char) -> *mut GString;
    pub fn g_string_new_len(init: *const c_char, len: ssize_t) -> *mut GString;
    pub fn g_string_sized_new(dfl_size: size_t) -> *mut GString;
    pub fn g_strip_context(msgid: *const c_char, msgval: *const c_char) -> *const c_char;
    pub fn g_strjoin(separator: *const c_char, ...) -> *mut c_char;
    pub fn g_strjoinv(separator: *const c_char, str_array: *mut *mut c_char) -> *mut c_char;
    pub fn g_strlcat(dest: *mut c_char, src: *const c_char, dest_size: size_t) -> size_t;
    pub fn g_strlcpy(dest: *mut c_char, src: *const c_char, dest_size: size_t) -> size_t;
    pub fn g_strncasecmp(s1: *const c_char, s2: *const c_char, n: c_uint) -> c_int;
    pub fn g_strndup(str: *const c_char, n: size_t) -> *mut c_char;
    pub fn g_strnfill(length: size_t, fill_char: c_char) -> *mut c_char;
    pub fn g_strreverse(string: *mut c_char) -> *mut c_char;
    pub fn g_strrstr(haystack: *const c_char, needle: *const c_char) -> *mut c_char;
    pub fn g_strrstr_len(haystack: *const c_char, haystack_len: ssize_t, needle: *const c_char) -> *mut c_char;
    pub fn g_strsignal(signum: c_int) -> *const c_char;
    pub fn g_strsplit(string: *const c_char, delimiter: *const c_char, max_tokens: c_int) -> *mut *mut c_char;
    pub fn g_strsplit_set(string: *const c_char, delimiters: *const c_char, max_tokens: c_int) -> *mut *mut c_char;
    pub fn g_strstr_len(haystack: *const c_char, haystack_len: ssize_t, needle: *const c_char) -> *mut c_char;
    pub fn g_strtod(nptr: *const c_char, endptr: *mut *mut c_char) -> c_double;
    pub fn g_strup(string: *mut c_char) -> *mut c_char;
    #[cfg(any(feature = "v2_44", feature = "dox"))]
    pub fn g_strv_contains(strv: *const *const c_char, str: *const c_char) -> gboolean;
    pub fn g_strv_get_type() -> GType;
    pub fn g_strv_length(str_array: *mut *mut c_char) -> c_uint;
    pub fn g_test_add_data_func(testpath: *const c_char, test_data: gconstpointer, test_func: GTestDataFunc);
    #[cfg(any(feature = "v2_34", feature = "dox"))]
    pub fn g_test_add_data_func_full(testpath: *const c_char, test_data: gpointer, test_func: GTestDataFunc, data_free_func: GDestroyNotify);
    pub fn g_test_add_func(testpath: *const c_char, test_func: GTestFunc);
    pub fn g_test_add_vtable(testpath: *const c_char, data_size: size_t, test_data: gconstpointer, data_setup: GTestFixtureFunc, data_test: GTestFixtureFunc, data_teardown: GTestFixtureFunc);
    pub fn g_test_assert_expected_messages_internal(domain: *const c_char, file: *const c_char, line: c_int, func: *const c_char);
    pub fn g_test_bug(bug_uri_snippet: *const c_char);
    pub fn g_test_bug_base(uri_pattern: *const c_char);
    #[cfg(any(feature = "v2_38", feature = "dox"))]
    pub fn g_test_build_filename(file_type: GTestFileType, first_path: *const c_char, ...) -> *mut c_char;
    pub fn g_test_create_case(test_name: *const c_char, data_size: size_t, test_data: gconstpointer, data_setup: GTestFixtureFunc, data_test: GTestFixtureFunc, data_teardown: GTestFixtureFunc) -> *mut GTestCase;
    pub fn g_test_create_suite(suite_name: *const c_char) -> *mut GTestSuite;
    #[cfg(any(feature = "v2_34", feature = "dox"))]
    pub fn g_test_expect_message(log_domain: *const c_char, log_level: GLogLevelFlags, pattern: *const c_char);
    pub fn g_test_fail();
    #[cfg(any(feature = "v2_38", feature = "dox"))]
    pub fn g_test_failed() -> gboolean;
    #[cfg(any(feature = "v2_38", feature = "dox"))]
    pub fn g_test_get_dir(file_type: GTestFileType) -> *mut c_char;
    #[cfg(any(feature = "v2_38", feature = "dox"))]
    pub fn g_test_get_filename(file_type: GTestFileType, first_path: *const c_char, ...) -> *const c_char;
    pub fn g_test_get_root() -> *mut GTestSuite;
    #[cfg(any(feature = "v2_38", feature = "dox"))]
    pub fn g_test_incomplete(msg: *const c_char);
    pub fn g_test_init(argc: *mut c_int, argv: *mut *mut *mut c_char, ...);
    pub fn g_test_log_set_fatal_handler(log_func: GTestLogFatalFunc, user_data: gpointer);
    pub fn g_test_log_type_name(log_type: GTestLogType) -> *const c_char;
    pub fn g_test_maximized_result(maximized_quantity: c_double, format: *const c_char, ...);
    pub fn g_test_message(format: *const c_char, ...);
    pub fn g_test_minimized_result(minimized_quantity: c_double, format: *const c_char, ...);
    pub fn g_test_queue_destroy(destroy_func: GDestroyNotify, destroy_data: gpointer);
    pub fn g_test_queue_free(gfree_pointer: gpointer);
    pub fn g_test_rand_double() -> c_double;
    pub fn g_test_rand_double_range(range_start: c_double, range_end: c_double) -> c_double;
    pub fn g_test_rand_int() -> i32;
    pub fn g_test_rand_int_range(begin: i32, end: i32) -> i32;
    pub fn g_test_run() -> c_int;
    pub fn g_test_run_suite(suite: *mut GTestSuite) -> c_int;
    #[cfg(any(feature = "v2_38", feature = "dox"))]
    pub fn g_test_set_nonfatal_assertions();
    #[cfg(any(feature = "v2_38", feature = "dox"))]
    pub fn g_test_skip(msg: *const c_char);
    #[cfg(any(feature = "v2_38", feature = "dox"))]
    pub fn g_test_subprocess() -> gboolean;
    pub fn g_test_timer_elapsed() -> c_double;
    pub fn g_test_timer_last() -> c_double;
    pub fn g_test_timer_start();
    pub fn g_test_trap_assertions(domain: *const c_char, file: *const c_char, line: c_int, func: *const c_char, assertion_flags: u64, pattern: *const c_char);
    pub fn g_test_trap_fork(usec_timeout: u64, test_trap_flags: GTestTrapFlags) -> gboolean;
    pub fn g_test_trap_has_passed() -> gboolean;
    pub fn g_test_trap_reached_timeout() -> gboolean;
    #[cfg(any(feature = "v2_38", feature = "dox"))]
    pub fn g_test_trap_subprocess(test_path: *const c_char, usec_timeout: u64, test_flags: GTestSubprocessFlags);
    pub fn g_timeout_add(interval: c_uint, function: GSourceFunc, data: gpointer) -> c_uint;
    pub fn g_timeout_add_full(priority: c_int, interval: c_uint, function: GSourceFunc, data: gpointer, notify: GDestroyNotify) -> c_uint;
    pub fn g_timeout_add_seconds(interval: c_uint, function: GSourceFunc, data: gpointer) -> c_uint;
    pub fn g_timeout_add_seconds_full(priority: c_int, interval: c_uint, function: GSourceFunc, data: gpointer, notify: GDestroyNotify) -> c_uint;
    pub fn g_timeout_source_new(interval: c_uint) -> *mut GSource;
    pub fn g_timeout_source_new_seconds(interval: c_uint) -> *mut GSource;
    pub fn g_try_malloc(n_bytes: size_t) -> gpointer;
    pub fn g_try_malloc0(n_bytes: size_t) -> gpointer;
    pub fn g_try_malloc0_n(n_blocks: size_t, n_block_bytes: size_t) -> gpointer;
    pub fn g_try_malloc_n(n_blocks: size_t, n_block_bytes: size_t) -> gpointer;
    pub fn g_try_realloc(mem: gpointer, n_bytes: size_t) -> gpointer;
    pub fn g_try_realloc_n(mem: gpointer, n_blocks: size_t, n_block_bytes: size_t) -> gpointer;
    pub fn g_ucs4_to_utf16(str: *const u32, len: c_long, items_read: *mut c_long, items_written: *mut c_long, error: *mut *mut GError) -> *mut u16;
    pub fn g_ucs4_to_utf8(str: *const u32, len: c_long, items_read: *mut c_long, items_written: *mut c_long, error: *mut *mut GError) -> *mut c_char;
    pub fn g_unichar_break_type(c: u32) -> GUnicodeBreakType;
    pub fn g_unichar_combining_class(uc: u32) -> c_int;
    pub fn g_unichar_compose(a: u32, b: u32, ch: *mut u32) -> gboolean;
    pub fn g_unichar_decompose(ch: u32, a: *mut u32, b: *mut u32) -> gboolean;
    pub fn g_unichar_digit_value(c: u32) -> c_int;
    pub fn g_unichar_fully_decompose(ch: u32, compat: gboolean, result: *mut u32, result_len: size_t) -> size_t;
    pub fn g_unichar_get_mirror_char(ch: u32, mirrored_ch: *mut u32) -> gboolean;
    pub fn g_unichar_get_script(ch: u32) -> GUnicodeScript;
    pub fn g_unichar_isalnum(c: u32) -> gboolean;
    pub fn g_unichar_isalpha(c: u32) -> gboolean;
    pub fn g_unichar_iscntrl(c: u32) -> gboolean;
    pub fn g_unichar_isdefined(c: u32) -> gboolean;
    pub fn g_unichar_isdigit(c: u32) -> gboolean;
    pub fn g_unichar_isgraph(c: u32) -> gboolean;
    pub fn g_unichar_islower(c: u32) -> gboolean;
    pub fn g_unichar_ismark(c: u32) -> gboolean;
    pub fn g_unichar_isprint(c: u32) -> gboolean;
    pub fn g_unichar_ispunct(c: u32) -> gboolean;
    pub fn g_unichar_isspace(c: u32) -> gboolean;
    pub fn g_unichar_istitle(c: u32) -> gboolean;
    pub fn g_unichar_isupper(c: u32) -> gboolean;
    pub fn g_unichar_iswide(c: u32) -> gboolean;
    pub fn g_unichar_iswide_cjk(c: u32) -> gboolean;
    pub fn g_unichar_isxdigit(c: u32) -> gboolean;
    pub fn g_unichar_iszerowidth(c: u32) -> gboolean;
    pub fn g_unichar_to_utf8(c: u32, outbuf: *mut c_char) -> c_int;
    pub fn g_unichar_tolower(c: u32) -> u32;
    pub fn g_unichar_totitle(c: u32) -> u32;
    pub fn g_unichar_toupper(c: u32) -> u32;
    pub fn g_unichar_type(c: u32) -> GUnicodeType;
    pub fn g_unichar_validate(ch: u32) -> gboolean;
    pub fn g_unichar_xdigit_value(c: u32) -> c_int;
    pub fn g_unicode_canonical_decomposition(ch: u32, result_len: *mut size_t) -> *mut u32;
    pub fn g_unicode_canonical_ordering(string: *mut u32, len: size_t);
    pub fn g_unicode_script_from_iso15924(iso15924: u32) -> GUnicodeScript;
    pub fn g_unicode_script_to_iso15924(script: GUnicodeScript) -> u32;
    pub fn g_unix_error_quark() -> GQuark;
    #[cfg(any(feature = "v2_36", feature = "dox"))]
    pub fn g_unix_fd_add(fd: c_int, condition: GIOCondition, function: GUnixFDSourceFunc, user_data: gpointer) -> c_uint;
    #[cfg(any(feature = "v2_36", feature = "dox"))]
    pub fn g_unix_fd_add_full(priority: c_int, fd: c_int, condition: GIOCondition, function: GUnixFDSourceFunc, user_data: gpointer, notify: GDestroyNotify) -> c_uint;
    #[cfg(any(feature = "v2_36", feature = "dox"))]
    pub fn g_unix_fd_source_new(fd: c_int, condition: GIOCondition) -> *mut GSource;
    pub fn g_unix_open_pipe(fds: *mut c_int, flags: c_int, error: *mut *mut GError) -> gboolean;
    pub fn g_unix_set_fd_nonblocking(fd: c_int, nonblock: gboolean, error: *mut *mut GError) -> gboolean;
    pub fn g_unix_signal_add(signum: c_int, handler: GSourceFunc, user_data: gpointer) -> c_uint;
    pub fn g_unix_signal_add_full(priority: c_int, signum: c_int, handler: GSourceFunc, user_data: gpointer, notify: GDestroyNotify) -> c_uint;
    pub fn g_unix_signal_source_new(signum: c_int) -> *mut GSource;
    pub fn g_unlink(filename: *mut c_char) -> c_int;
    #[cfg(any(windows, feature = "dox"))]
    pub fn g_unsetenv_utf8(variable: *const c_char);
    pub fn g_unsetenv(variable: *const c_char);
    pub fn g_uri_escape_string(unescaped: *const c_char, reserved_chars_allowed: *const c_char, allow_utf8: gboolean) -> *mut c_char;
    pub fn g_uri_list_extract_uris(uri_list: *const c_char) -> *mut *mut c_char;
    pub fn g_uri_parse_scheme(uri: *const c_char) -> *mut c_char;
    pub fn g_uri_unescape_segment(escaped_string: *const c_char, escaped_string_end: *const c_char, illegal_characters: *const c_char) -> *mut c_char;
    pub fn g_uri_unescape_string(escaped_string: *const c_char, illegal_characters: *const c_char) -> *mut c_char;
    pub fn g_usleep(microseconds: c_ulong);
    pub fn g_utf16_to_ucs4(str: *const u16, len: c_long, items_read: *mut c_long, items_written: *mut c_long, error: *mut *mut GError) -> *mut u32;
    pub fn g_utf16_to_utf8(str: *const u16, len: c_long, items_read: *mut c_long, items_written: *mut c_long, error: *mut *mut GError) -> *mut c_char;
    pub fn g_utf8_casefold(str: *const c_char, len: ssize_t) -> *mut c_char;
    pub fn g_utf8_collate(str1: *const c_char, str2: *const c_char) -> c_int;
    pub fn g_utf8_collate_key(str: *const c_char, len: ssize_t) -> *mut c_char;
    pub fn g_utf8_collate_key_for_filename(str: *const c_char, len: ssize_t) -> *mut c_char;
    pub fn g_utf8_find_next_char(p: *const c_char, end: *const c_char) -> *mut c_char;
    pub fn g_utf8_find_prev_char(str: *const c_char, p: *const c_char) -> *mut c_char;
    pub fn g_utf8_get_char(p: *const c_char) -> u32;
    pub fn g_utf8_get_char_validated(p: *const c_char, max_len: ssize_t) -> u32;
    #[cfg(any(feature = "v2_52", feature = "dox"))]
    pub fn g_utf8_make_valid(str: *const c_char, len: ssize_t) -> *mut c_char;
    pub fn g_utf8_normalize(str: *const c_char, len: ssize_t, mode: GNormalizeMode) -> *mut c_char;
    pub fn g_utf8_offset_to_pointer(str: *const c_char, offset: c_long) -> *mut c_char;
    pub fn g_utf8_pointer_to_offset(str: *const c_char, pos: *const c_char) -> c_long;
    pub fn g_utf8_prev_char(p: *const c_char) -> *mut c_char;
    pub fn g_utf8_strchr(p: *const c_char, len: ssize_t, c: u32) -> *mut c_char;
    pub fn g_utf8_strdown(str: *const c_char, len: ssize_t) -> *mut c_char;
    pub fn g_utf8_strlen(p: *const c_char, max: ssize_t) -> c_long;
    pub fn g_utf8_strncpy(dest: *mut c_char, src: *const c_char, n: size_t) -> *mut c_char;
    pub fn g_utf8_strrchr(p: *const c_char, len: ssize_t, c: u32) -> *mut c_char;
    pub fn g_utf8_strreverse(str: *const c_char, len: ssize_t) -> *mut c_char;
    pub fn g_utf8_strup(str: *const c_char, len: ssize_t) -> *mut c_char;
    pub fn g_utf8_substring(str: *const c_char, start_pos: c_long, end_pos: c_long) -> *mut c_char;
    pub fn g_utf8_to_ucs4(str: *const c_char, len: c_long, items_read: *mut c_long, items_written: *mut c_long, error: *mut *mut GError) -> *mut u32;
    pub fn g_utf8_to_ucs4_fast(str: *const c_char, len: c_long, items_written: *mut c_long) -> *mut u32;
    pub fn g_utf8_to_utf16(str: *const c_char, len: c_long, items_read: *mut c_long, items_written: *mut c_long, error: *mut *mut GError) -> *mut u16;
    pub fn g_utf8_validate(str: *mut u8, max_len: ssize_t, end: *mut *const c_char) -> gboolean;
    #[cfg(any(feature = "v2_52", feature = "dox"))]
    pub fn g_uuid_string_is_valid(str: *const c_char) -> gboolean;
    #[cfg(any(feature = "v2_52", feature = "dox"))]
    pub fn g_uuid_string_random() -> *mut c_char;
    pub fn g_variant_get_gtype() -> GType;
    //pub fn g_vasprintf(string: *mut *mut c_char, format: *mut c_char, args: /*Unimplemented*/va_list) -> c_int;
    //pub fn g_vfprintf(file: *mut FILE, format: *mut c_char, args: /*Unimplemented*/va_list) -> c_int;
    //pub fn g_vprintf(format: *mut c_char, args: /*Unimplemented*/va_list) -> c_int;
    //pub fn g_vsnprintf(string: *mut c_char, n: c_ulong, format: *mut c_char, args: /*Unimplemented*/va_list) -> c_int;
    //pub fn g_vsprintf(string: *mut c_char, format: *mut c_char, args: /*Unimplemented*/va_list) -> c_int;
    pub fn g_warn_message(domain: *const c_char, file: *const c_char, line: c_int, func: *const c_char, warnexpr: *const c_char);

}
